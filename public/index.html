<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1"
    />
    <title>Document</title>
    <style>
      section {
        width: 100%;
        height: 100%;
        border: 1px solid #2d2d2d;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      canvas {
        display: inline-block;
        height: 100%;
        width: 100%;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        background-color: #000;
      }

      #frame {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 40px;
        background-color: transparent;
        z-index: 2;
        -webkit-app-region: drag;
      }
    </style>
  </head>
  <body>
    <div id="frame"></div>
    <section id="game"></section>
    <script>
      (function () {
        var RetroBuffer = function (width, height, atlas, pages) {
          this.WIDTH = width;
          this.HEIGHT = height;
          this.PAGESIZE = this.WIDTH * this.HEIGHT;
          this.PAGES = pages;
          this.atlas = atlas;

          this.SCREEN = 0;
          this.PAGE_1 = this.PAGESIZE;
          this.PAGE_2 = this.PAGESIZE * 2;
          this.PAGE_3 = this.PAGESIZE * 3;
          this.PAGE_4 = this.PAGESIZE * 4;

          //relative drawing position and pencolor, for drawing functions that require it.
          this.cursorX = 0;
          this.cursorY = 0;
          this.cursorColor = 23;
          this.cursorColor2 = 25;
          this.stencil = false;
          this.stencilSource = this.PAGE_2;
          this.stencilOffset = 0;

          this.colors = this.atlas.slice(0, 64);

          //default palette index
          this.palDefault = [
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
            19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
            36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
            53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
          ];

          this.c = document.createElement("canvas");
          this.c.width = this.WIDTH;
          this.c.height = this.HEIGHT;
          this.ctx = this.c.getContext("2d");
          this.renderTarget = 0x00000;
          this.renderSource = this.PAGESIZE; //buffer is ahead one screen's worth of pixels

          this.fontString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_!@#.'\"?/<()";

          this.fontBitmap =
            "11111100011111110001100011111010001111101000111110111111000010000100000111111100100101000110001111101111110000111001000011111111111000" +
            "0111001000010000111111000010111100011111110001100011111110001100011111100100001000010011111111110001000010100101111010001100101110010010100011000" +
            "0100001000010000111111000111011101011000110001100011100110101100111000101110100011000110001011101111010001100101110010000011101000110001100100111" +
            "1111101000111110100011000101111100000111000001111101111100100001000010000100100011000110001100010111010001100011000101010001001000110001101011010" +
            "1011101000101010001000101010001100010101000100001000010011111000100010001000111110010001100001000010001110011101000100010001001111111110000010011" +
            "0000011111010010100101111100010000101111110000111100000111110011111000011110100010111011111000010001000100001000111010001011101000101110011101000" +
            "1011110000101110011101000110001100010111000000000000000000000111110010000100001000000000100111111000110111101011011101010111110101011111010100000" +
            "000000000000000000100001100001000100000000000011011010011001000000000000111010001001100000000100000010001000100010001000000010001000100000100000100001000100001000010000010";

          this.pal = [
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
            19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
            36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
            53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
          ];

          this.dither = [
            0b1111111111111111, 0b1111111111110111, 0b1111110111110111,
            0b1111110111110101, 0b1111010111110101, 0b1111010110110101,
            0b1110010110110101, 0b1110010110100101, 0b1010010110100101,
            0b1010010110100001, 0b1010010010100001, 0b1010010010100000,
            0b1010000010100000, 0b1010000000100000, 0b1000000000100000,
            0b1000000000000000, 0b0000000000000000, 0b1111100110011111,
            0b0000011001100000, 0b1111100010001000,
          ];

          this.pat = 0b1111111111111111;

          this.ctx.imageSmoothingEnabled = false;

          (this.imageData = this.ctx.getImageData(
            0,
            0,
            this.WIDTH,
            this.HEIGHT,
          )),
            (this.buf = new ArrayBuffer(this.imageData.data.length)),
            (this.buf8 = new Uint8Array(this.buf)),
            (this.data = new Uint32Array(this.buf)),
            (this.ram = new Uint8Array(this.WIDTH * this.HEIGHT * this.PAGES));

          //Brightness LUT
          this.brightness = [];
          for (let i = 0; i < 6; i++) {
            for (let j = 0; j < 64; j++) {
              this.brightness[i * 64 + j] = this.colors.indexOf(
                this.atlas[i * 64 + j],
              );
            }
            //ram[address + i] = colors.indexOf(data[i]);
          }

          //--------------graphics functions----------------

          this.clear = function (color, page) {
            this.ram.fill(color, page, page + this.PAGESIZE);
          };

          return this;
        };

        RetroBuffer.prototype.setPen = function (color, color2, dither = 0) {
          this.cursorColor = color;
          this.cursorColor2 = color2;
          this.pat = dither;
        };

        RetroBuffer.prototype.pset = function pset(x, y, color, color2 = 64) {
          x = x | 0;
          y = y | 0;
          color = this.stencil
            ? this.pget(x, y, this.stencilSource) + this.stencilOffset
            : (color | 0) % 64;
          let px = (y % 4) * 4 + (x % 4);
          let mask = this.pat & Math.pow(2, px);
          let pcolor = mask ? color : color2;
          if (pcolor == 64) return;
          if ((x < 0) | (x > this.WIDTH - 1)) return;
          if ((y < 0) | (y > this.HEIGHT - 1)) return;

          this.ram[this.renderTarget + y * this.WIDTH + x] = pcolor;
        };

        RetroBuffer.prototype.pget = function pget(x, y, page = 0) {
          x = x | 0;
          y = y | 0;
          return this.ram[page + x + y * this.WIDTH];
        };

        RetroBuffer.prototype.line = function line(x1, y1, x2, y2, color) {
          (x1 = x1 | 0), (x2 = x2 | 0), (y1 = y1 | 0), (y2 = y2 | 0);

          var dy = y2 - y1;
          var dx = x2 - x1;
          var stepx, stepy;

          if (dy < 0) {
            dy = -dy;
            stepy = -1;
          } else {
            stepy = 1;
          }
          if (dx < 0) {
            dx = -dx;
            stepx = -1;
          } else {
            stepx = 1;
          }
          dy <<= 1; // dy is now 2*dy
          dx <<= 1; // dx is now 2*dx

          this.pset(x1, y1, color);
          if (dx > dy) {
            var fraction = dy - (dx >> 1); // same as 2*dy - dx
            while (x1 != x2) {
              if (fraction >= 0) {
                y1 += stepy;
                fraction -= dx; // same as fraction -= 2*dx
              }
              x1 += stepx;
              fraction += dy; // same as fraction -= 2*dy
              this.pset(x1, y1, color);
            }
          } else {
            fraction = dx - (dy >> 1);
            while (y1 != y2) {
              if (fraction >= 0) {
                x1 += stepx;
                fraction -= dy;
              }
              y1 += stepy;
              fraction += dx;
              this.pset(x1, y1, color);
            }
          }
        };

        RetroBuffer.prototype.tline = function tline(
          x1,
          y1,
          x2,
          y2,
          offsetX = 0,
          offsetY = 0,
          colorOffset = 0,
        ) {
          (x1 = x1 | 0), (x2 = x2 | 0), (y1 = y1 | 0), (y2 = y2 | 0);

          var dy = y2 - y1;
          var dx = x2 - x1;
          var stepx, stepy;

          if (dy < 0) {
            dy = -dy;
            stepy = -1;
          } else {
            stepy = 1;
          }
          if (dx < 0) {
            dx = -dx;
            stepx = -1;
          } else {
            stepx = 1;
          }
          dy <<= 1; // dy is now 2*dy
          dx <<= 1; // dx is now 2*dx

          var x = x1,
            y = y1;
          var fraction = dy - (dx >> 1); // same as 2*dy - dx
          while (x != x2) {
            if (fraction >= 0) {
              y += stepy;
              fraction -= dx; // same as fraction -= 2*dx
            }
            x += stepx;
            fraction += dy; // same as fraction -= 2*dy
            this.pset(
              x,
              y,
              this.pget(x - offsetX, y - offsetY, this.renderSource) +
                colorOffset,
            );
          }
        };

        RetroBuffer.prototype.circle = function circle(xm, ym, r, color) {
          xm = xm | 0;
          ym = ym | 0;
          r = r | 0;
          color = color | 0;
          var x = -r,
            y = 0,
            err = 2 - 2 * r;
          /* II. Quadrant */
          do {
            this.pset(xm - x, ym + y, color);
            /*   I. Quadrant */
            this.pset(xm - y, ym - x, color);
            /*  II. Quadrant */
            this.pset(xm + x, ym - y, color);
            /* III. Quadrant */
            this.pset(xm + y, ym + x, color);
            /*  IV. Quadrant */
            r = err;
            if (r <= y) err += ++y * 2 + 1;
            /* e_xy+e_y < 0 */
            if (r > x || err > y) err += ++x * 2 + 1;
            /* e_xy+e_x > 0 or no 2nd y-step */
          } while (x < 0);
        };

        RetroBuffer.prototype.fillCircle = function fillCircle(
          xm,
          ym,
          r,
          color,
        ) {
          xm = xm | 0;
          ym = ym | 0;
          r = r | 0;
          color = color | 0;
          if (r < 0) return;
          xm = xm | 0;
          (ym = ym | 0), (r = r | 0);
          var x = -r,
            y = 0,
            err = 2 - 2 * r;
          /* II. Quadrant */
          do {
            this.line(xm - x, ym - y, xm + x, ym - y, color);
            this.line(xm - x, ym + y, xm + x, ym + y, color);
            r = err;
            if (r <= y) err += ++y * 2 + 1;
            if (r > x || err > y) err += ++x * 2 + 1;
          } while (x < 0);
        };

        RetroBuffer.prototype.tfillCircle = function tfillCircle(
          xm,
          ym,
          r,
          colorOffset = 0,
        ) {
          xm = xm | 0;
          ym = ym | 0;
          r = r | 0;
          offX = xm - mw; //+ r;
          offY = ym - mh; //+ r;
          if (r < 0) return;
          xm = xm | 0;
          (ym = ym | 0), (r = r | 0);
          var x = -r,
            y = 0,
            err = 2 - 2 * r;
          /* II. Quadrant */
          do {
            this.tline(xm - x, ym - y, xm + x, ym - y, offX, offY, colorOffset);
            this.tline(xm - x, ym + y, xm + x, ym + y, offX, offY, colorOffset);
            r = err;
            if (r <= y) err += ++y * 2 + 1;
            if (r > x || err > y) err += ++x * 2 + 1;
          } while (x < 0);
        };

        RetroBuffer.prototype.rect = function rect(x, y, w, h, color) {
          color = color | this.cursorColor;
          //let { line } = this;
          let x1 = x | 0,
            y1 = y | 0,
            x2 = (x + w) | 0,
            y2 = (y + h) | 0;

          this.line(x1, y1, x2, y1, color);
          this.line(x2, y1, x2, y2, color);
          this.line(x1, y2, x2, y2, color);
          this.line(x1, y1, x1, y2, color);
        };

        RetroBuffer.prototype.fillRect = function fillRect(x, y, w, h, color) {
          let x1 = x | 0,
            y1 = y | 0,
            x2 = ((x + w) | 0) - 1,
            y2 = ((y + h) | 0) - 1;
          color = color;

          var i = Math.abs(y2 - y1);
          this.line(x1, y1, x2, y1, color);

          if (i > 0) {
            while (--i) {
              this.line(x1, y1 + i, x2, y1 + i, color);
            }
          }

          this.line(x1, y2, x2, y2, color);
        };

        RetroBuffer.prototype.sspr = function sspr(
          sx = 0,
          sy = 0,
          sw = 16,
          sh = 16,
          x = 0,
          y = 0,
          dw = 32,
          dh = 32,
          flipx = false,
          flipy = false,
        ) {
          var xratio = sw / dw;
          var yratio = sh / dh;
          this.pat = this.dither[0]; //reset pattern
          for (var i = 0; i < dh; i++) {
            for (var j = 0; j < dw; j++) {
              px = (j * xratio) | 0;
              py = (i * yratio) | 0;
              sy = flipy ? sh - py - i : sy;
              sx = flipx ? sw - px - j : sx;
              source = this.pget(sx + px, sy + py, this.renderSource);
              if (source > 0) {
                this.pset(x + j, y + i, source);
              }
            }
          }
        };

        RetroBuffer.prototype.outline = function outline(
          renderSource,
          renderTarget,
          color,
          color2,
          color3,
          color4,
        ) {
          for (let i = 0; i <= this.WIDTH; i++) {
            for (let j = 0; j <= this.HEIGHT; j++) {
              let left = i - 1 + j * this.WIDTH;
              let right = i + 1 + j * this.WIDTH;
              let bottom = i + (j + 1) * this.WIDTH;
              let top = i + (j - 1) * this.WIDTH;
              let current = i + j * this.WIDTH;

              if (this.ram[this.renderSource + current]) {
                if (this.ram[this.renderSource + left] == 64) {
                  this.ram[this.renderTarget + left] = color;
                }
                if (this.ram[this.renderSource + right] == 64) {
                  this.ram[this.renderTarget + right] = color3;
                }
                if (this.ram[this.renderSource + top] == 64) {
                  this.ram[this.renderTarget + top] = color2;
                }
                if (this.ram[this.renderSource + bottom] == 64) {
                  this.ram[this.renderTarget + bottom] = color4;
                }
              }
            }
          }
        };

        RetroBuffer.prototype.triangle = function triangle(p1, p2, p3, color) {
          this.line(p1.x, p1.y, p2.x, p2.y, color);
          this.line(p2.x, p2.y, p3.x, p3.y, color);
          this.line(p3.x, p3.y, p1.x, p1.y, color);
        };

        //from https://www-users.mat.uni.torun.pl//~wrona/3d_tutor/tri_fillers.html
        RetroBuffer.prototype.fillTriangle = function fillTriangle(
          p1,
          p2,
          p3,
          color,
        ) {
          //sort vertices by y, top first

          let P = [
            Object.assign({}, p1),
            Object.assign({}, p2),
            Object.assign({}, p3),
          ].sort((a, b) => a.y - b.y);
          let A = P[0],
            B = P[1],
            C = P[2],
            dx1 = 0,
            dx2 = 0,
            dx3 = 0,
            S = {},
            E = {};

          if (B.y - A.y > 0) dx1 = (B.x - A.x) / (B.y - A.y);
          if (C.y - A.y > 0) dx2 = (C.x - A.x) / (C.y - A.y);
          if (C.y - B.y > 0) dx3 = (C.x - B.x) / (C.y - B.y);

          Object.assign(S, A);
          Object.assign(E, A);
          if (dx1 > dx2) {
            for (; S.y <= B.y; S.y++, E.y++, S.x += dx2, E.x += dx1) {
              this.line(S.x, S.y, E.x, S.y, color);
            }
            E = B;
            for (; S.y <= C.y; S.y++, E.y++, S.x += dx2, E.x += dx3)
              this.line(S.x, S.y, E.x, S.y, color);
          } else {
            for (; S.y <= B.y; S.y++, E.y++, S.x += dx1, E.x += dx2) {
              this.line(S.x, S.y, E.x, S.y, color);
            }
            S = B;
            for (; S.y <= C.y; S.y++, E.y++, S.x += dx3, E.x += dx2) {
              this.line(S.x, S.y, E.x, S.y, color);
            }
          }
        };

        RetroBuffer.prototype.imageToRam = function imageToRam(image, address) {
          //var image = E.smallcanvas.toDataURL("image/png");
          let tempCanvas = document.createElement("canvas");
          tempCanvas.width = WIDTH;
          tempCanvas.height = HEIGHT;
          let context = tempCanvas.getContext("2d");
          //draw image to canvas
          context.drawImage(image, 0, 0);

          //get image data
          var imageData = context.getImageData(0, 0, WIDTH, HEIGHT);

          //set up 32bit view of buffer
          let data = new Uint32Array(imageData.data.buffer);

          //compare buffer to palette (loop)
          for (var i = 0; i < data.length; i++) {
            ram[address + i] = colors.indexOf(data[i]);
          }
        };

        RetroBuffer.prototype.render = function render() {
          var i = this.PAGESIZE; // display is first page of ram

          while (i--) {
            /*
        data is 32bit view of final screen buffer
        for each pixel on screen, we look up it's color and assign it
        */
            if (i > 0) this.data[i] = this.colors[this.pal[this.ram[i]]];
          }

          this.imageData.data.set(this.buf8);
          this.c.width = this.c.width;
          this.ctx.putImageData(this.imageData, 0, 0);
        };

        //o is an array of options with the following structure:
        /* [textstring, x, y, hspacing, vspacing, halign, valign, scale, color, offset, delay, frequency]
  0: text
  1: x
  2: y
  3: hspacing
  4: vspacing
  5: halign
  6: valign
  7: scale
  8: color
  //options 9-11 are for animating the text per-character. just sin motion
  9: per character offset
  10: delay, higher is slower
  11: frequency
  */
        RetroBuffer.prototype.textLine = function textLine(o) {
          var textLength = o[0].length,
            size = 5;

          for (var i = 0; i < textLength; i++) {
            var letter = [];
            letter = this.getCharacter(o[0].charAt(i));

            for (var y = 0; y < size; y++) {
              for (var x = 0; x < size; x++) {
                if (letter[y * size + x] == 1) {
                  if (o[4] == 1) {
                    this.pset(
                      o[1] + x * o[4] + (size * o[4] + o[3]) * i,
                      (o[2] + y * o[4]) | 0,
                      o[5],
                    );
                  } else {
                    let cx = o[1] + x * o[4] + (size * o[4] + o[3]) * i;
                    let cy = (o[2] + y * o[4]) | 0;
                    this.fillRect(cx, cy, o[4], o[4], o[5]);
                  }
                } //end draw routine
              } //end x loop
            } //end y loop
          } //end text loop
        }; //end textLine()

        RetroBuffer.prototype.text = function text(o) {
          var size = 5,
            letterSize = size * o[7],
            lines = o[0].split("\n"),
            linesCopy = lines.slice(0),
            lineCount = lines.length,
            longestLine = linesCopy.sort(function (a, b) {
              return b.length - a.length;
            })[0],
            textWidth =
              longestLine.length * letterSize + (longestLine.length - 1) * o[3],
            textHeight = lineCount * letterSize + (lineCount - 1) * o[4];

          if (!o[5]) o[5] = "left";
          if (!o[6]) o[6] = "bottom";

          var sx = o[1],
            sy = o[2],
            ex = o[1] + textWidth,
            ey = o[2] + textHeight;

          if (o[5] == "center") {
            sx = o[1] - textWidth / 2;
            ex = o[1] + textWidth / 2;
          } else if (o[5] == "right") {
            sx = o[1] - textWidth;
            ex = o[1];
          }

          if (o[6] == "center") {
            sy = o[2] - textHeight / 2;
            ey = o[2] + textHeight / 2;
          } else if (o[6] == "bottom") {
            sy = o[2] - textHeight;
            ey = o[2];
          }

          var cx = sx + textWidth / 2,
            cy = sy + textHeight / 2;

          for (var i = 0; i < lineCount; i++) {
            var line = lines[i],
              lineWidth = line.length * letterSize + (line.length - 1) * o[3],
              x = o[1],
              y = o[2] + (letterSize + o[4]) * i;

            if (o[5] == "center") {
              x = o[1] - lineWidth / 2;
            } else if (o[5] == "right") {
              x = o[1] - lineWidth;
            }

            if (o[6] == "center") {
              y = y - textHeight / 2;
            } else if (o[6] == "bottom") {
              y = y - textHeight;
            }

            this.textLine([line, x, y, o[3], o[7], o[8]]);
          }

          return {
            sx: sx,
            sy: sy,
            cx: cx,
            cy: cy,
            ex: ex,
            ey: ey,
            width: textWidth,
            height: textHeight,
          };
        };

        RetroBuffer.prototype.getCharacter = function getCharacter(char) {
          index = this.fontString.indexOf(char);
          return this.fontBitmap
            .substring(index * 25, index * 25 + 25)
            .split("");
        };

        /* -*- mode: javascript; tab-width: 4; indent-tabs-mode: nil; -*-
         *
         * Copyright (c) 2011-2013 Marcus Geelnard
         *
         * This software is provided 'as-is', without any express or implied
         * warranty. In no event will the authors be held liable for any damages
         * arising from the use of this software.
         *
         * Permission is granted to anyone to use this software for any purpose,
         * including commercial applications, and to alter it and redistribute it
         * freely, subject to the following restrictions:
         *
         * 1. The origin of this software must not be misrepresented; you must not
         *    claim that you wrote the original software. If you use this software
         *    in a product, an acknowledgment in the product documentation would be
         *    appreciated but is not required.
         *
         * 2. Altered source versions must be plainly marked as such, and must not be
         *    misrepresented as being the original software.
         *
         * 3. This notice may not be removed or altered from any source
         *    distribution.
         *
         */

        //"use strict";

        // Some general notes and recommendations:
        //  * This code uses modern ECMAScript features, such as ** instead of
        //    Math.pow(). You may have to modify the code to make it work on older
        //    browsers.
        //  * If you're not using all the functionality (e.g. not all oscillator types,
        //    or certain effects), you can reduce the size of the player routine even
        //    further by deleting the code.

        var MusicPlayer = function () {
          //--------------------------------------------------------------------------
          // Private methods
          //--------------------------------------------------------------------------

          // Oscillators
          var osc_sin = function (value) {
            return Math.sin(value * 6.283184);
          };

          var osc_saw = function (value) {
            return 2 * (value % 1) - 1;
          };

          var osc_square = function (value) {
            return value % 1 < 0.5 ? 1 : -1;
          };

          var osc_tri = function (value) {
            var v2 = (value % 1) * 4;
            if (v2 < 2) return v2 - 1;
            return 3 - v2;
          };

          var getnotefreq = function (n) {
            // 174.61.. / 44100 = 0.003959503758 (F3)
            return 0.003959503758 * 2 ** ((n - 128) / 12);
          };

          var createNote = function (instr, n, rowLen) {
            var osc1 = mOscillators[instr.i[0]],
              o1vol = instr.i[1],
              o1xenv = instr.i[3] / 32,
              osc2 = mOscillators[instr.i[4]],
              o2vol = instr.i[5],
              o2xenv = instr.i[8] / 32,
              noiseVol = instr.i[9],
              attack = instr.i[10] * instr.i[10] * 4,
              sustain = instr.i[11] * instr.i[11] * 4,
              release = instr.i[12] * instr.i[12] * 4,
              releaseInv = 1 / release,
              expDecay = -instr.i[13] / 16,
              arp = instr.i[14],
              arpInterval = rowLen * 2 ** (2 - instr.i[15]);

            var noteBuf = new Int32Array(attack + sustain + release);

            // Re-trig oscillators
            var c1 = 0,
              c2 = 0;

            // Local variables.
            var j, j2, e, rsample, o1t, o2t;

            // Generate one note (attack + sustain + release)
            for (j = 0, j2 = 0; j < attack + sustain + release; j++, j2++) {
              if (j2 >= 0) {
                // Switch arpeggio note.
                arp = (arp >> 8) | ((arp & 255) << 4);
                j2 -= arpInterval;

                // Calculate note frequencies for the oscillators
                o1t = getnotefreq(n + (arp & 15) + instr.i[2] - 128);
                o2t =
                  getnotefreq(n + (arp & 15) + instr.i[6] - 128) *
                  (1 + 0.0008 * instr.i[7]);
              }

              // Envelope
              e = 1;
              if (j < attack) {
                e = j / attack;
              } else if (j >= attack + sustain) {
                e = (j - attack - sustain) * releaseInv;
                e = (1 - e) * 3 ** (expDecay * e);
              }

              // Oscillator 1
              c1 += o1t * e ** o1xenv;
              rsample = osc1(c1) * o1vol;

              // Oscillator 2
              c2 += o2t * e ** o2xenv;
              rsample += osc2(c2) * o2vol;

              // Noise oscillator
              if (noiseVol) {
                rsample += (2 * Math.random() - 1) * noiseVol;
              }

              // Add to (mono) channel buffer
              noteBuf[j] = (80 * rsample * e) | 0;
            }

            return noteBuf;
          };

          //--------------------------------------------------------------------------
          // Private members
          //--------------------------------------------------------------------------

          // Array of oscillator functions
          var mOscillators = [osc_sin, osc_square, osc_saw, osc_tri];

          // Private variables set up by init()
          var mSong, mLastRow, mCurrentCol, mNumWords, mMixBuf;

          //--------------------------------------------------------------------------
          // Initialization
          //--------------------------------------------------------------------------

          this.init = function (song) {
            // Define the song
            mSong = song;

            // Init iteration state variables
            mLastRow = song.endPattern;
            mCurrentCol = 0;

            // Prepare song info
            mNumWords = song.rowLen * song.patternLen * (mLastRow + 1) * 2;

            // Create work buffer (initially cleared)
            mMixBuf = new Int32Array(mNumWords);
          };

          //--------------------------------------------------------------------------
          // Public methods
          //--------------------------------------------------------------------------

          // Generate audio data for a single track
          this.generate = function () {
            // Local variables
            var i, j, p, row, col, n, cp, k, t, rsample, rowStartSample, f;

            // Put performance critical items in local variables
            var chnBuf = new Int32Array(mNumWords),
              instr = mSong.songData[mCurrentCol],
              rowLen = mSong.rowLen,
              patternLen = mSong.patternLen;

            // Clear effect state
            var low = 0,
              band = 0,
              high;
            var lsample,
              filterActive = false;

            // Clear note cache.
            var noteCache = [];

            // Patterns
            for (p = 0; p <= mLastRow; ++p) {
              cp = instr.p[p];

              // Pattern rows
              for (row = 0; row < patternLen; ++row) {
                // Execute effect command.
                var cmdNo = cp ? instr.c[cp - 1].f[row] : 0;
                if (cmdNo) {
                  instr.i[cmdNo - 1] = instr.c[cp - 1].f[row + patternLen] || 0;

                  // Clear the note cache since the instrument has changed.
                  if (cmdNo < 17) {
                    noteCache = [];
                  }
                }

                // Put performance critical instrument properties in local variables
                var oscLFO = mOscillators[instr.i[16]],
                  lfoAmt = instr.i[17] / 512,
                  lfoFreq = 2 ** (instr.i[18] - 9) / rowLen,
                  fxLFO = instr.i[19],
                  fxFilter = instr.i[20],
                  fxFreq = (instr.i[21] * 43.23529 * 3.141592) / 44100,
                  q = 1 - instr.i[22] / 255,
                  dist = instr.i[23] * 1e-5,
                  drive = instr.i[24] / 32,
                  panAmt = instr.i[25] / 512,
                  panFreq = (6.283184 * 2 ** (instr.i[26] - 9)) / rowLen,
                  dlyAmt = instr.i[27] / 255,
                  dly = (instr.i[28] * rowLen) & ~1; // Must be an even number

                // Calculate start sample number for this row in the pattern
                rowStartSample = (p * patternLen + row) * rowLen;

                // Generate notes for this pattern row
                for (col = 0; col < 4; ++col) {
                  n = cp ? instr.c[cp - 1].n[row + col * patternLen] : 0;
                  if (n) {
                    if (!noteCache[n]) {
                      noteCache[n] = createNote(instr, n, rowLen);
                    }

                    // Copy note from the note cache
                    var noteBuf = noteCache[n];
                    for (
                      j = 0, i = rowStartSample * 2;
                      j < noteBuf.length;
                      j++, i += 2
                    ) {
                      chnBuf[i] += noteBuf[j];
                    }
                  }
                }

                // Perform effects for this pattern row
                for (j = 0; j < rowLen; j++) {
                  // Dry mono-sample
                  k = (rowStartSample + j) * 2;
                  rsample = chnBuf[k];

                  // We only do effects if we have some sound input
                  if (rsample || filterActive) {
                    // State variable filter
                    f = fxFreq;
                    if (fxLFO) {
                      f *= oscLFO(lfoFreq * k) * lfoAmt + 0.5;
                    }
                    f = 1.5 * Math.sin(f);
                    low += f * band;
                    high = q * (rsample - band) - low;
                    band += f * high;
                    rsample = fxFilter == 3 ? band : fxFilter == 1 ? high : low;

                    // Distortion
                    if (dist) {
                      rsample *= dist;
                      rsample =
                        rsample < 1
                          ? rsample > -1
                            ? osc_sin(rsample * 0.25)
                            : -1
                          : 1;
                      rsample /= dist;
                    }

                    // Drive
                    rsample *= drive;

                    // Is the filter active (i.e. still audiable)?
                    filterActive = rsample * rsample > 1e-5;

                    // Panning
                    t = Math.sin(panFreq * k) * panAmt + 0.5;
                    lsample = rsample * (1 - t);
                    rsample *= t;
                  } else {
                    lsample = 0;
                  }

                  // Delay is always done, since it does not need sound input
                  if (k >= dly) {
                    // Left channel = left + right[-p] * t
                    lsample += chnBuf[k - dly + 1] * dlyAmt;

                    // Right channel = right + left[-p] * t
                    rsample += chnBuf[k - dly] * dlyAmt;
                  }

                  // Store in stereo channel buffer (needed for the delay effect)
                  chnBuf[k] = lsample | 0;
                  chnBuf[k + 1] = rsample | 0;

                  // ...and add to stereo mix buffer
                  mMixBuf[k] += lsample | 0;
                  mMixBuf[k + 1] += rsample | 0;
                }
              }
            }

            // Next iteration. Return progress (1.0 == done!).
            mCurrentCol++;
            return mCurrentCol / mSong.numChannels;
          };

          // Create a AudioBuffer from the generated audio data
          this.createAudioBuffer = function (context) {
            var buffer = context.createBuffer(2, mNumWords / 2, 44100);
            for (var i = 0; i < 2; i++) {
              var data = buffer.getChannelData(i);
              for (var j = i; j < mNumWords; j += 2) {
                data[j >> 1] = mMixBuf[j] / 65536;
              }
            }
            return buffer;
          };

          // Create a WAVE formatted Uint8Array from the generated audio data
          this.createWave = function () {
            // Create WAVE header
            var headerLen = 44;
            var l1 = headerLen + mNumWords * 2 - 8;
            var l2 = l1 - 36;
            var wave = new Uint8Array(headerLen + mNumWords * 2);
            wave.set([
              82,
              73,
              70,
              70,
              l1 & 255,
              (l1 >> 8) & 255,
              (l1 >> 16) & 255,
              (l1 >> 24) & 255,
              87,
              65,
              86,
              69,
              102,
              109,
              116,
              32,
              16,
              0,
              0,
              0,
              1,
              0,
              2,
              0,
              68,
              172,
              0,
              0,
              16,
              177,
              2,
              0,
              4,
              0,
              16,
              0,
              100,
              97,
              116,
              97,
              l2 & 255,
              (l2 >> 8) & 255,
              (l2 >> 16) & 255,
              (l2 >> 24) & 255,
            ]);

            // Append actual wave data
            for (var i = 0, idx = headerLen; i < mNumWords; ++i) {
              // Note: We clamp here
              var y = mMixBuf[i];
              y = y < -32767 ? -32767 : y > 32767 ? 32767 : y;
              wave[idx++] = y & 255;
              wave[idx++] = (y >> 8) & 255;
            }

            // Return the WAVE formatted typed array
            return wave;
          };

          // Get n samples of wave data at time t [s]. Wave data in range [-2,2].
          this.getData = function (t, n) {
            var i = 2 * Math.floor(t * 44100);
            var d = new Array(n);
            for (var j = 0; j < 2 * n; j += 1) {
              var k = i + j;
              d[j] = t > 0 && k < mMixBuf.length ? mMixBuf[k] / 32768 : 0;
            }
            return d;
          };
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var song = {
          songData: [
            {
              // Instrument 0
              i: [
                0, // OSC1_WAVEFORM
                192, // OSC1_VOL
                128, // OSC1_SEMI
                0, // OSC1_XENV
                0, // OSC2_WAVEFORM
                191, // OSC2_VOL
                116, // OSC2_SEMI
                9, // OSC2_DETUNE
                0, // OSC2_XENV
                0, // NOISE_VOL
                6, // ENV_ATTACK
                22, // ENV_SUSTAIN
                34, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                69, // LFO_AMT
                3, // LFO_FREQ
                1, // LFO_FX_FREQ
                1, // FX_FILTER
                0, // FX_FREQ
                16, // FX_RESONANCE
                0, // FX_DIST
                16, // FX_DRIVE
                170, // FX_PAN_AMT
                6, // FX_PAN_FREQ
                25, // FX_DELAY_AMT
                6, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1, 2, 1, 2, 1, 2, 1, 2, 1, 1],
              // Columns
              c: [
                {
                  n: [
                    123,
                    ,
                    ,
                    ,
                    ,
                    ,
                    135,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    133,
                    ,
                    ,
                    ,
                    133,
                    ,
                    ,
                    ,
                    133,
                    ,
                    ,
                    ,
                    130,
                    ,
                    133,
                    ,
                    135,
                  ],
                  f: [],
                },
                { n: [123, , , , , , 135, , , , , , , , 133], f: [] },
              ],
            },
            {
              // Instrument 1
              i: [
                0, // OSC1_WAVEFORM
                91, // OSC1_VOL
                128, // OSC1_SEMI
                0, // OSC1_XENV
                0, // OSC2_WAVEFORM
                95, // OSC2_VOL
                128, // OSC2_SEMI
                12, // OSC2_DETUNE
                0, // OSC2_XENV
                0, // NOISE_VOL
                12, // ENV_ATTACK
                0, // ENV_SUSTAIN
                72, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                0, // LFO_AMT
                0, // LFO_FREQ
                0, // LFO_FX_FREQ
                2, // FX_FILTER
                255, // FX_FREQ
                0, // FX_RESONANCE
                0, // FX_DIST
                32, // FX_DRIVE
                83, // FX_PAN_AMT
                3, // FX_PAN_FREQ
                130, // FX_DELAY_AMT
                4, // FX_DELAY_TIME
              ],
              // Patterns
              p: [, , 1, , 1, 1, 1, 1, 1, 1],
              // Columns
              c: [
                {
                  n: [
                    135,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    139,
                  ],
                  f: [],
                },
              ],
            },
            {
              // Instrument 2
              i: [
                3, // OSC1_WAVEFORM
                194, // OSC1_VOL
                128, // OSC1_SEMI
                0, // OSC1_XENV
                2, // OSC2_WAVEFORM
                198, // OSC2_VOL
                128, // OSC2_SEMI
                6, // OSC2_DETUNE
                0, // OSC2_XENV
                0, // NOISE_VOL
                12, // ENV_ATTACK
                12, // ENV_SUSTAIN
                33, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                61, // LFO_AMT
                4, // LFO_FREQ
                1, // LFO_FX_FREQ
                2, // FX_FILTER
                109, // FX_FREQ
                86, // FX_RESONANCE
                7, // FX_DIST
                32, // FX_DRIVE
                112, // FX_PAN_AMT
                3, // FX_PAN_FREQ
                67, // FX_DELAY_AMT
                2, // FX_DELAY_TIME
              ],
              // Patterns
              p: [, , , , 1, 2, 1, 2, 3, 4],
              // Columns
              c: [
                {
                  n: [
                    ,
                    ,
                    ,
                    ,
                    130,
                    ,
                    ,
                    ,
                    ,
                    ,
                    130,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    128,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    135,
                    ,
                    ,
                    ,
                    ,
                    ,
                    135,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    133,
                  ],
                  f: [],
                },
                {
                  n: [
                    ,
                    ,
                    ,
                    ,
                    123,
                    ,
                    ,
                    ,
                    ,
                    ,
                    123,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    123,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    127,
                    ,
                    ,
                    ,
                    ,
                    ,
                    127,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    128,
                  ],
                  f: [],
                },
                {
                  n: [
                    ,
                    ,
                    ,
                    ,
                    123,
                    ,
                    ,
                    ,
                    ,
                    ,
                    130,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    123,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    127,
                    ,
                    ,
                    ,
                    ,
                    ,
                    127,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    128,
                  ],
                  f: [],
                },
                {
                  n: [
                    ,
                    ,
                    ,
                    ,
                    130,
                    ,
                    ,
                    ,
                    ,
                    ,
                    130,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    130,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    135,
                    ,
                    ,
                    ,
                    ,
                    ,
                    135,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    135,
                  ],
                  f: [],
                },
              ],
            },
          ],
          rowLen: 5513, // In sample lengths
          patternLen: 32, // Rows per pattern
          endPattern: 9, // End pattern
          numChannels: 3, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var cellComplete = {
          songData: [
            {
              // Instrument 0
              i: [
                2, // OSC1_WAVEFORM
                100, // OSC1_VOL
                128, // OSC1_SEMI
                0, // OSC1_XENV
                3, // OSC2_WAVEFORM
                201, // OSC2_VOL
                128, // OSC2_SEMI
                0, // OSC2_DETUNE
                0, // OSC2_XENV
                0, // NOISE_VOL
                5, // ENV_ATTACK
                6, // ENV_SUSTAIN
                58, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                195, // LFO_AMT
                6, // LFO_FREQ
                1, // LFO_FX_FREQ
                2, // FX_FILTER
                135, // FX_FREQ
                0, // FX_RESONANCE
                0, // FX_DIST
                32, // FX_DRIVE
                147, // FX_PAN_AMT
                6, // FX_PAN_FREQ
                28, // FX_DELAY_AMT
                6, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [
                {
                  n: [
                    147,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    152,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    154,
                  ],
                  f: [],
                },
              ],
            },
          ],
          rowLen: 5088, // In sample lengths
          patternLen: 32, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var tada = {
          songData: [
            {
              // Instrument 0
              i: [
                2, // OSC1_WAVEFORM
                100, // OSC1_VOL
                128, // OSC1_SEMI
                0, // OSC1_XENV
                3, // OSC2_WAVEFORM
                201, // OSC2_VOL
                128, // OSC2_SEMI
                0, // OSC2_DETUNE
                0, // OSC2_XENV
                0, // NOISE_VOL
                5, // ENV_ATTACK
                6, // ENV_SUSTAIN
                58, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                195, // LFO_AMT
                6, // LFO_FREQ
                1, // LFO_FX_FREQ
                2, // FX_FILTER
                135, // FX_FREQ
                0, // FX_RESONANCE
                0, // FX_DIST
                32, // FX_DRIVE
                147, // FX_PAN_AMT
                6, // FX_PAN_FREQ
                55, // FX_DELAY_AMT
                6, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [
                {
                  n: [
                    151,
                    151,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    154,
                    154,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    159,
                    159,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    135,
                    135,
                  ],
                  f: [],
                },
              ],
            },
          ],
          rowLen: 6014, // In sample lengths
          patternLen: 32, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var absorbray = {
          songData: [
            {
              // Instrument 0
              i: [
                1, // OSC1_WAVEFORM
                255, // OSC1_VOL
                128, // OSC1_SEMI
                0, // OSC1_XENV
                1, // OSC2_WAVEFORM
                154, // OSC2_VOL
                128, // OSC2_SEMI
                9, // OSC2_DETUNE
                0, // OSC2_XENV
                0, // NOISE_VOL
                7, // ENV_ATTACK
                5, // ENV_SUSTAIN
                52, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                0, // LFO_AMT
                0, // LFO_FREQ
                0, // LFO_FX_FREQ
                2, // FX_FILTER
                14, // FX_FREQ
                47, // FX_RESONANCE
                0, // FX_DIST
                32, // FX_DRIVE
                4, // FX_PAN_AMT
                5, // FX_PAN_FREQ
                24, // FX_DELAY_AMT
                2, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [
                {
                  n: [
                    135, 149, 147, 149, 147, 149, 147, 149, 147, 149, 147, 149,
                    147, 149, 147, 149, 147, 149, 147, 149, 147, 149, 147, 149,
                    147, 149, 147, 149, 147, 149, 147, 149, 151, 152, 151, 152,
                    151, 152, 151, 152, 151, 152, 151, 152, 151, 152, 151, 152,
                    151, 152, 151, 152, 151, 152, 151, 152, 151, 152, 151, 152,
                    151, 152, 151, 152,
                  ],
                  f: [],
                },
              ],
            },
          ],
          rowLen: 2756, // In sample lengths
          patternLen: 32, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var boom1 = {
          songData: [
            {
              // Instrument 0
              i: [
                0, // OSC1_WAVEFORM
                255, // OSC1_VOL
                116, // OSC1_SEMI
                64, // OSC1_XENV
                0, // OSC2_WAVEFORM
                255, // OSC2_VOL
                108, // OSC2_SEMI
                2, // OSC2_DETUNE
                64, // OSC2_XENV
                182, // NOISE_VOL
                4, // ENV_ATTACK
                6, // ENV_SUSTAIN
                154, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                0, // LFO_AMT
                0, // LFO_FREQ
                0, // LFO_FX_FREQ
                2, // FX_FILTER
                14, // FX_FREQ
                33, // FX_RESONANCE
                10, // FX_DIST
                68, // FX_DRIVE
                0, // FX_PAN_AMT
                0, // FX_PAN_FREQ
                0, // FX_DELAY_AMT
                0, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [{ n: [147], f: [] }],
            },
          ],
          rowLen: 5513, // In sample lengths
          patternLen: 32, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var jet = {
          songData: [
            {
              // Instrument 0
              i: [
                0, // OSC1_WAVEFORM
                0, // OSC1_VOL
                140, // OSC1_SEMI
                0, // OSC1_XENV
                0, // OSC2_WAVEFORM
                0, // OSC2_VOL
                140, // OSC2_SEMI
                0, // OSC2_DETUNE
                0, // OSC2_XENV
                255, // NOISE_VOL
                0, // ENV_ATTACK
                255, // ENV_SUSTAIN
                255, // ENV_RELEASE
                19, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                0, // LFO_AMT
                0, // LFO_FREQ
                0, // LFO_FX_FREQ
                3, // FX_FILTER
                3, // FX_FREQ
                57, // FX_RESONANCE
                20, // FX_DIST
                59, // FX_DRIVE
                0, // FX_PAN_AMT
                0, // FX_PAN_FREQ
                157, // FX_DELAY_AMT
                2, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [
                {
                  n: [
                    123,
                    ,
                    ,
                    ,
                    ,
                    111,
                    ,
                    ,
                    ,
                    111,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    135,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    111,
                    ,
                    ,
                    ,
                    123,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    139,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    137,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    140,
                    ,
                    ,
                    ,
                    ,
                    ,
                    111,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    139,
                    ,
                    ,
                    ,
                    111,
                    ,
                    ,
                    ,
                    ,
                    ,
                    111,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    142,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    111,
                    ,
                    ,
                    ,
                    140,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    111,
                    ,
                    ,
                    139,
                  ],
                  f: [],
                },
              ],
            },
          ],
          rowLen: 5513, // In sample lengths
          patternLen: 64, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var sectorget = {
          songData: [
            {
              // Instrument 0
              i: [
                1, // OSC1_WAVEFORM
                192, // OSC1_VOL
                128, // OSC1_SEMI
                0, // OSC1_XENV
                1, // OSC2_WAVEFORM
                191, // OSC2_VOL
                116, // OSC2_SEMI
                9, // OSC2_DETUNE
                0, // OSC2_XENV
                0, // NOISE_VOL
                6, // ENV_ATTACK
                22, // ENV_SUSTAIN
                34, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                69, // LFO_AMT
                3, // LFO_FREQ
                1, // LFO_FX_FREQ
                1, // FX_FILTER
                23, // FX_FREQ
                167, // FX_RESONANCE
                0, // FX_DIST
                32, // FX_DRIVE
                77, // FX_PAN_AMT
                6, // FX_PAN_FREQ
                25, // FX_DELAY_AMT
                6, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [{ n: [163, 159, 161, 166], f: [] }],
            },
          ],
          rowLen: 5011, // In sample lengths
          patternLen: 12, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var bump = {
          songData: [
            {
              // Instrument 0
              i: [
                0, // OSC1_WAVEFORM
                255, // OSC1_VOL
                116, // OSC1_SEMI
                60, // OSC1_XENV
                0, // OSC2_WAVEFORM
                255, // OSC2_VOL
                116, // OSC2_SEMI
                0, // OSC2_DETUNE
                104, // OSC2_XENV
                0, // NOISE_VOL
                0, // ENV_ATTACK
                6, // ENV_SUSTAIN
                125, // ENV_RELEASE
                52, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                0, // LFO_AMT
                0, // LFO_FREQ
                0, // LFO_FX_FREQ
                2, // FX_FILTER
                48, // FX_FREQ
                0, // FX_RESONANCE
                0, // FX_DIST
                35, // FX_DRIVE
                0, // FX_PAN_AMT
                0, // FX_PAN_FREQ
                57, // FX_DELAY_AMT
                2, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [{ n: [159], f: [] }],
            },
          ],
          rowLen: 5513, // In sample lengths
          patternLen: 32, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var babyaction = {
          songData: [
            {
              // Instrument 0
              i: [
                0, // OSC1_WAVEFORM
                255, // OSC1_VOL
                116, // OSC1_SEMI
                9, // OSC1_XENV
                0, // OSC2_WAVEFORM
                255, // OSC2_VOL
                116, // OSC2_SEMI
                0, // OSC2_DETUNE
                5, // OSC2_XENV
                0, // NOISE_VOL
                4, // ENV_ATTACK
                6, // ENV_SUSTAIN
                68, // ENV_RELEASE
                52, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                0, // LFO_AMT
                0, // LFO_FREQ
                0, // LFO_FX_FREQ
                2, // FX_FILTER
                14, // FX_FREQ
                0, // FX_RESONANCE
                0, // FX_DIST
                32, // FX_DRIVE
                0, // FX_PAN_AMT
                0, // FX_PAN_FREQ
                52, // FX_DELAY_AMT
                2, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [
                {
                  n: [
                    171,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    175,
                  ],
                  f: [],
                },
              ],
            },
          ],
          rowLen: 5513, // In sample lengths
          patternLen: 32, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var babyaction2 = {
          songData: [
            {
              // Instrument 0
              i: [
                0, // OSC1_WAVEFORM
                91, // OSC1_VOL
                128, // OSC1_SEMI
                0, // OSC1_XENV
                0, // OSC2_WAVEFORM
                95, // OSC2_VOL
                128, // OSC2_SEMI
                12, // OSC2_DETUNE
                0, // OSC2_XENV
                0, // NOISE_VOL
                12, // ENV_ATTACK
                0, // ENV_SUSTAIN
                72, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                0, // LFO_WAVEFORM
                0, // LFO_AMT
                0, // LFO_FREQ
                0, // LFO_FX_FREQ
                2, // FX_FILTER
                255, // FX_FREQ
                0, // FX_RESONANCE
                0, // FX_DIST
                32, // FX_DRIVE
                83, // FX_PAN_AMT
                3, // FX_PAN_FREQ
                43, // FX_DELAY_AMT
                4, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [{ n: [159, 156], f: [] }],
            },
          ],
          rowLen: 5513, // In sample lengths
          patternLen: 32, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var dronemoan = {
          songData: [
            {
              // Instrument 0
              i: [
                3, // OSC1_WAVEFORM
                146, // OSC1_VOL
                140, // OSC1_SEMI
                0, // OSC1_XENV
                1, // OSC2_WAVEFORM
                224, // OSC2_VOL
                128, // OSC2_SEMI
                3, // OSC2_DETUNE
                0, // OSC2_XENV
                0, // NOISE_VOL
                92, // ENV_ATTACK
                0, // ENV_SUSTAIN
                44, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                3, // LFO_WAVEFORM
                179, // LFO_AMT
                5, // LFO_FREQ
                1, // LFO_FX_FREQ
                2, // FX_FILTER
                124, // FX_FREQ
                135, // FX_RESONANCE
                11, // FX_DIST
                32, // FX_DRIVE
                150, // FX_PAN_AMT
                3, // FX_PAN_FREQ
                125, // FX_DELAY_AMT
                6, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [
                {
                  n: [
                    99,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    100,
                  ],
                  f: [],
                },
              ],
            },
          ],
          rowLen: 5513, // In sample lengths
          patternLen: 32, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        var harvestermoan = {
          songData: [
            {
              // Instrument 0
              i: [
                3, // OSC1_WAVEFORM
                146, // OSC1_VOL
                140, // OSC1_SEMI
                0, // OSC1_XENV
                1, // OSC2_WAVEFORM
                224, // OSC2_VOL
                128, // OSC2_SEMI
                3, // OSC2_DETUNE
                0, // OSC2_XENV
                0, // NOISE_VOL
                60, // ENV_ATTACK
                0, // ENV_SUSTAIN
                49, // ENV_RELEASE
                0, // ENV_EXP_DECAY
                0, // ARP_CHORD
                0, // ARP_SPEED
                3, // LFO_WAVEFORM
                179, // LFO_AMT
                5, // LFO_FREQ
                1, // LFO_FX_FREQ
                2, // FX_FILTER
                124, // FX_FREQ
                135, // FX_RESONANCE
                11, // FX_DIST
                32, // FX_DRIVE
                150, // FX_PAN_AMT
                3, // FX_PAN_FREQ
                125, // FX_DELAY_AMT
                3, // FX_DELAY_TIME
              ],
              // Patterns
              p: [1],
              // Columns
              c: [
                {
                  n: [
                    111,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    ,
                    121,
                  ],
                  f: [],
                },
              ],
            },
          ],
          rowLen: 5513, // In sample lengths
          patternLen: 32, // Rows per pattern
          endPattern: 0, // End pattern
          numChannels: 1, // Number of channels
        };

        function rand(min, max) {
          return Math.floor(Math.random() * (max + 1 - min) + min);
        }
        function choice(values) {
          return values[rand(0, values.length - 1)];
        }
        function lerp(a, b, x) {
          return a + (b - a) * x;
        }

        function doesPlanetHaveCollision(planet, spaceBetween) {
          for (var i = 0; i < planets.length; i++) {
            var otherPlanet = planets[i];
            var a = planet.field + otherPlanet.field + spaceBetween;
            var x = planet.x - otherPlanet.x;
            var y = planet.y - otherPlanet.y;

            if (a >= Math.sqrt(x * x + y * y)) {
              return true;
            }
          }

          if (planet.x + planet.field >= Ww || planet.x - planet.field <= 0) {
            return true;
          }

          if (planet.y + planet.field >= Wh || planet.y - planet.field <= 0) {
            return true;
          }

          return false;
        }

        function inView(o, padding = 0) {
          return (
            o.x - view.x + padding > 0 &&
            o.y - view.y + padding > 0 &&
            o.x - view.x - padding < w &&
            o.y - view.y - padding < h
          );
        }

        function playSound(
          buffer,
          playbackRate = 1,
          pan = 0,
          volume = 0.5,
          loop = false,
        ) {
          var source = window.audioCtx.createBufferSource();
          var gainNode = window.audioCtx.createGain();
          var panNode = window.audioCtx.createStereoPanner();

          source.buffer = buffer;
          source.connect(panNode);
          panNode.connect(gainNode);
          gainNode.connect(audioMaster);

          source.playbackRate.value = playbackRate;
          source.loop = loop;
          gainNode.gain.value = volume;
          panNode.pan.value = pan;
          source.start();
          return { volume: gainNode, sound: source };
        }

        const Key = {
          _pressed: {},
          _released: {},

          LEFT: 37,
          UP: 38,
          RIGHT: 39,
          DOWN: 40,
          SPACE: 32,
          ONE: 49,
          TWO: 50,
          THREE: 51,
          FOUR: 52,
          a: 65,
          c: 67,
          w: 87,
          s: 83,
          d: 68,
          z: 90,
          x: 88,
          f: 70,
          p: 80,
          r: 82,
          m: 77,
          h: 72,

          isDown(keyCode) {
            return this._pressed[keyCode];
          },

          justReleased(keyCode) {
            return this._released[keyCode];
          },

          onKeydown(event) {
            this._pressed[event.keyCode] = true;
          },

          onKeyup(event) {
            this._released[event.keyCode] = true;
            delete this._pressed[event.keyCode];
          },

          update() {
            this._released = {};
          },
        };

        function Splode(x, y, life, color) {
          this.x = x;
          this.y = y;
          this.lifeMax = life;
          this.life = life;
          this.alive = true;
          this.color = color;
        }
        Splode.prototype.draw = function () {
          r.pat = r.dither[15 - Math.floor((this.life / this.lifeMax) * 15)];
          for (let i = Math.floor(this.life / 10); i > 0; i--) {
            r.circle(
              this.x - view.x,
              this.y - view.y,
              this.lifeMax - this.life - i,
              this.color,
            );
          }
          r.circle(
            this.x - view.x,
            this.y - view.y,
            this.lifeMax - this.life,
            this.color,
          );
          r.pat = r.dither[0];
        };
        Splode.prototype.update = function () {
          if (!this.alive) {
            return;
          }
          if (this.life > 0) {
            this.life -= 1;
          } else {
            this.alive = false;
          }
        };

        /*
  TODO: implement double jump or thrust after jump to escape from gravity
  */
        Player = {
          x: 0,
          y: 0,
          radius: 10,
          color: 4,
          colliding: false,
          withinPlanetGravity: false,
          hitPlanet: false,
          inAir: false,
          chargingJump: false,
          canJump: false,
          canDoubleJump: false,
          planet: null,
          py: 0,
          px: 0,
          angle: 0,
          bodyAngle: 0,
          armThrust: 0,
          legThrust: 0,
          planetAngle: 0,
          runSpeed: 2.1,
          turnSpeed: 0.15,
          baseJumpSpeed: 2.7,
          jumpSpeed: 2.7,
          jumpSpeedIncrement: 0.4,
          thrust: 0.1,
          yVel: 0,
          xVel: 0,
          maxXVel: 3.5,
          maxYVel: 3.5,
          fuel: 150,
          maxFuel: 300,
          fuelDecay: 0.025,
          draining: false,
          div12: Math.PI / 6,
          forwardX: 0,
          forwardy: 0,
          forwardXend: 0,
          forwardyend: 0,
          headx: 0,
          heady: 0,
          neckx: 0,
          necky: 0,
          foot1x: 0,
          foot1y: 0,
          foot2x: 0,
          foot2y: 0,
          arm1x: 0,
          arm1y: 0,
          arm2x: 0,
          arm2y: 0,
          jetnoise: {},
          babies: 0,
          init: false,
          absorbing: false,
          enemiesInView: [],

          draw: function () {
            r.pat = r.dither[0];
            let sx = this.x - view.x,
              sy = this.y - view.y,
              div12 = this.div12;

            sx + Math.cos(this.angle) * (this.radius + 5);
            sy + Math.sin(this.angle) * (this.radius + 5);
            sx + Math.cos(this.angle) * (this.radius + 7);
            sy + Math.sin(this.angle) * (this.radius + 7);

            let headx = sx + Math.cos(this.bodyAngle) * this.radius,
              heady = sy + Math.sin(this.bodyAngle) * this.radius,
              neckx = sx + Math.cos(this.bodyAngle) * (this.radius / 2),
              necky = sy + Math.sin(this.bodyAngle) * (this.radius / 2);

            this.arm1x = arm1x =
              neckx +
              Math.cos(this.bodyAngle + div12 * 3.5 + this.armThrust) *
                this.radius;
            this.arm1y = arm1y =
              necky +
              Math.sin(this.bodyAngle + div12 * 3.5 + this.armThrust) *
                this.radius;
            this.arm2x = arm2x =
              neckx +
              Math.cos(this.bodyAngle - div12 * 3.5 - this.armThrust) *
                this.radius;
            this.arm2y = arm2y =
              necky +
              Math.sin(this.bodyAngle - div12 * 3.5 - this.armThrust) *
                this.radius;

            this.foot1x = foot1x =
              sx +
              Math.cos(this.bodyAngle + div12 * 5 + this.legThrust) *
                this.radius;
            this.foot1y = foot1y =
              sy +
              Math.sin(this.bodyAngle + div12 * 5 + this.legThrust) *
                this.radius;
            this.foot2x = foot2x =
              sx +
              Math.cos(this.bodyAngle - div12 * 5 - this.legThrust) *
                this.radius;
            this.foot2y = foot2y =
              sy +
              Math.sin(this.bodyAngle - div12 * 5 - this.legThrust) *
                this.radius;

            //r.circle(sx, sy, this.radius, 1); //collide circle
            //r.line(forwardX, forwardy, forwardXend, forwardyend, 7); //forward line

            r.fillCircle(headx, heady, 2, 22); //head
            r.circle(foot1x, foot1y, 1, 22); //foot1
            r.circle(foot2x, foot2y, 1, 22); //foot2
            r.line(sx, sy, headx, heady, 22); //torso/neck line
            r.line(sx, sy, foot1x, foot1y, 22); //leg1
            r.line(sx, sy, foot2x, foot2y, 22); //leg2
            r.line(sx, sy, foot1x, foot1y, 22); //leg1
            r.line(sx, sy, foot2x, foot2y, 22); //leg2r.line(sx, sy, headx, heady, 22); //torso/neck line
            r.line(neckx, necky, arm1x, arm1y, 22); //arm1
            r.line(neckx, necky, arm2x, arm2y, 22); //arm2

            if (this.draining) {
              for (let i = 0; i < 100; i++) {
                let ra = Math.random() * 2 * Math.PI;
                r.pset(
                  sx + Math.cos(ra) * (this.radius + 5 + Math.random() * 5),
                  sy + Math.sin(ra) * (this.radius + 5 + Math.random() * 5),
                  choice([3, 4]),
                );
              }
            }

            // debugTxt =
            // // `${this.withinPlanetGravity}\n
            // // XV ${this.xVel}\n
            // // YV ${this.yVel}\n
            // `JS ${this.jumpSpeed}\n
            // FUEL: ${this.fuel}\n
            // ARM: ${this.armThrust}\nYV: ${this.yVel}\nXV: ${this.xVel}\n`
            // //VX ${view.x} VY ${view.y}\n
            // .toUpperCase();

            //         r.text([debugTxt, 5, 5, 1, 1, 'left', 'top', 1, 22]);
          },

          update: function () {
            this.fuel -= this.fuelDecay;
            if (!this.init) {
              this.jetnoise = playSound(sounds.jet, 0.6, 0, 0.1, true);
              this.jetnoise.volume.gain.value = 0;
              this.init = true;
            } else {
              this.jetnoise.volume.gain.value = 0;
            }
            this.yVel = this.yVel > this.maxYVel ? this.maxYVel : this.yVel;
            this.xVel = this.xVel > this.maxXVel ? this.maxXVel : this.xVel;
            this.yVel = this.yVel < -this.maxYVel ? -this.maxYVel : this.yVel;
            this.xVel = this.xVel < -this.maxXVel ? -this.maxXVel : this.xVel;
            this.y += this.yVel;
            this.x += this.xVel;
            if (this.x > Ww) {
              this.x = 0;
            } else if (this.x < 0) {
              this.x = Ww;
            }
            if (this.y > Wh) {
              this.y = 0;
            } else if (this.y < 0) {
              this.y = Wh;
            }

            this.bodyAngle = this.angle; // - Math.PI/2;

            if (!this.colliding) {
              let velAngle = Math.atan2(this.yVel, this.xVel);

              this.armThrust = this.legThrust = Math.cos(
                this.bodyAngle - velAngle,
              );
            }

            if (this.withinPlanetGravity) {
              this.angle = this.planetAngle;
              this.legThrust = Math.cos(t / 10);
            }

            if (this.fuel <= 0) {
              this.fuel = 0;
            }

            if (this.fuel > this.maxFuel) {
              this.fuel = this.maxFuel;
            }

            if (this.planet) {
              let distx = this.planet.x - p.x;
              let disty = this.planet.y - p.y;
              let dist = Math.sqrt(distx * distx + disty * disty);
              if (dist >= this.planet.radius + this.radius) {
                this.colliding = false;
              }
              if (dist >= this.planet.field + this.radius) {
                this.withinPlanetGravity = false;
              }
              if (dist <= this.planet.radius) {
                this.colliding = true;
              }
              if (this.withinPlanetGravity) {
                //gravity towards planet
                this.py = this.y - this.planet.y;
                this.px = this.x - this.planet.x;
                this.planetAngle = Math.atan2(this.py, this.px);
                this.bodyAngle = this.planetAngle;
                this.xVel -= Math.cos(this.planetAngle) * this.planet.gravity;
                this.yVel -= Math.sin(this.planetAngle) * this.planet.gravity;
              }
            }

            if (this.colliding) {
              this.yVel = 0;
              this.xVel = 0;
            }

            if (
              Key.isDown(Key.LEFT) ||
              Key.isDown(Key.q) ||
              Key.isDown(Key.a)
            ) {
              this.moveLeft();
            } else if (Key.isDown(Key.RIGHT) || Key.isDown(Key.d)) {
              this.moveRight();
            }

            if (Key.isDown(Key.UP) || Key.isDown(Key.z) || Key.isDown(Key.w)) {
              this.moveUp();
            } else if (Key.isDown(Key.DOWN) || Key.isDown(Key.w)) {
              this.moveDown();
            }
          },

          moveLeft: function () {
            if (this.colliding) {
              this.xVel -=
                Math.cos(this.planetAngle + Math.PI / 2) * this.runSpeed;
              this.yVel -=
                Math.sin(this.planetAngle + Math.PI / 2) * this.runSpeed;
            } else {
              this.angle -= this.turnSpeed;
              this.angle = this.angle % (Math.PI * 2);
              if (!this.withinPlanetGravity) {
                splodes.push(
                  new Splode(
                    this.arm1x + view.x,
                    this.arm1y + view.y,
                    5,
                    choice([19, 20, 22]),
                  ),
                );
                this.jetnoise.volume.gain.value = 0.03;
              }
            }
          },

          moveRight: function () {
            if (this.colliding) {
              this.xVel -=
                Math.cos(this.planetAngle - Math.PI / 2) * this.runSpeed;
              this.yVel -=
                Math.sin(this.planetAngle - Math.PI / 2) * this.runSpeed;
            } else {
              this.angle += this.turnSpeed;
              this.angle = this.angle % (Math.PI * 2);
              if (!this.withinPlanetGravity) {
                splodes.push(
                  new Splode(
                    this.arm2x + view.x,
                    this.arm2y + view.y,
                    5,
                    choice([19, 20, 22]),
                  ),
                );
                this.jetnoise.volume.gain.value = 0.03;
              }
            }
          },

          moveUp: function () {
            if (this.colliding) {
              this.xVel += Math.cos(this.planetAngle) * this.jumpSpeed;
              this.yVel += Math.sin(this.planetAngle) * this.jumpSpeed;
            } else {
              this.xVel += Math.cos(this.angle) * this.thrust;
              this.yVel += Math.sin(this.angle) * this.thrust;

              if (!this.withinPlanetGravity) {
                splodes.push(
                  new Splode(
                    this.foot1x + view.x,
                    this.foot1y + view.y,
                    5,
                    choice([7, 8, 22]),
                  ),
                );
                splodes.push(
                  new Splode(
                    this.foot2x + view.x,
                    this.foot2y + view.y,
                    5,
                    choice([7, 8, 22]),
                  ),
                );
                this.jetnoise.volume.gain.value = 0.03;
              }
            }
          },

          moveDown: function () {
            if (this.colliding);
            else {
              this.xVel -= Math.cos(this.angle) * this.thrust;
              this.yVel -= Math.sin(this.angle) * this.thrust;

              if (!this.withinPlanetGravity) {
                splodes.push(
                  new Splode(
                    this.arm1x + view.x,
                    this.arm1y + view.y,
                    5,
                    choice([19, 20, 22]),
                  ),
                );
                splodes.push(
                  new Splode(
                    this.arm2x + view.x,
                    this.arm2y + view.y,
                    5,
                    choice([19, 20, 22]),
                  ),
                );
                this.jetnoise.volume.gain.value = 0.03;
              }
            }
          },

          onPlanet: function (planet) {
            this.planet = planet;
            this.py = this.y - this.planet.y;
            this.px = this.x - this.planet.x;
            this.angle = Math.atan2(this.py, this.px);
            this.withinPlanetGravity = true;
          },

          reset: function () {
            this.fuel = 100;
            this.xVel = this.yVel = 0;
            p.x = Ww / 2;
            p.y = Wh / 2;
            babies = [];
          },
        };

        const Player$1 = Player;

        function Sector(x, y, planet) {
          this.x = x;
          this.y = y;
          this.radius = 0.1;
          this.maxRadius = 15;
          this.alive = true;
          this.reaching = false;
          this.angle = 0;
          this.planet = planet;
          this.complete = false;

          return this;
        }
        Sector.prototype.draw = function () {
          if (inView(this, 10)) {
            r.pat = r.dither[Math.random() < -0.5 ? 8 : 9];
            if (!this.complete) {
              r.fillCircle(
                this.x - view.x,
                this.y - view.y,
                this.radius + 5,
                14,
              );
              r.pat = r.dither[0];
              r.fillCircle(this.x - view.x, this.y - view.y, this.radius, 11);
              if (this.reaching) {
                let i = 10;
                while (i--) {
                  r.pat = r.dither[i];
                  r.line(
                    this.x - view.x + (Math.random() - 0.5) * this.radius * 2,
                    this.y - view.y + (Math.random() - 0.5) * this.radius * 2,
                    p.x - view.x,
                    p.y - view.y,
                    10 + Math.random() * 5,
                  );
                }
              }
            } else {
              r.circle(this.x - view.x, this.y - view.y, this.radius + 5, 19);
            }
          }
        };
        Sector.prototype.update = function () {
          if (inView(this, 10)) {
            let distx = this.x - p.x;
            let disty = this.y - p.y;

            let dist = Math.sqrt(distx * distx + disty * disty);

            if (dist <= this.radius + p.radius + 40 && p.fuel > 0) {
              if (this.radius < this.maxRadius) {
                this.radius += 0.3;
                p.fuel -= 0.6;
                this.planet.disease.splice(0, 1);
                this.reaching = true;
                sectorFillSound.volume.gain.value = 0.1;
              } else {
                this.reaching = false;
              }
            } else {
              this.reaching = false;
            }

            if (this.radius > this.maxRadius) {
              this.radius = this.maxRadius;
              if (!this.complete) {
                this.complete = true;
                playSound(sounds.sectorget);
                this.reaching = false;
                this.planet.sectorsRemaining--;
                splodes.push(
                  new Splode(
                    this.x + Math.random() * 10,
                    this.y + Math.random() * 10,
                    30,
                    14,
                  ),
                );
                splodes.push(
                  new Splode(
                    this.x + Math.random() * 10,
                    this.y + Math.random() * 10,
                    40,
                    15,
                  ),
                );
                splodes.push(
                  new Splode(
                    this.x + Math.random() * 10,
                    this.y + Math.random() * 10,
                    50,
                    16,
                  ),
                );
              }
            }

            if (this.planet.sectorsRemaining == 0) {
              this.alive = false;
            }
          }
          // if(this.radius <= 0){
          //     this.alive = false;
          // }
        };

        function Fuel(x, y, radius) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.alive = true;
          this.reaching = false;
          this.targetX = 0;
          this.targetY = 0;

          return this;
        }
        Fuel.prototype.draw = function () {
          if (inView(this, 10)) {
            r.pat = r.dither[Math.random() < -0.5 ? 8 : 9];
            r.fillCircle(this.x - view.x, this.y - view.y, this.radius + 5, 14);
            r.pat = r.dither[0];
            r.fillCircle(this.x - view.x, this.y - view.y, this.radius, 11);
            if (this.reaching) {
              let i = 10;
              while (i--) {
                r.pat = r.dither[i];
                r.line(
                  this.x - view.x + (Math.random() - 0.5) * this.radius * 2,
                  this.y - view.y + (Math.random() - 0.5) * this.radius * 2,
                  p.x - view.x,
                  p.y - view.y,
                  10 + Math.random() * 5,
                );
              }
            }
          }
        };
        Fuel.prototype.update = function () {
          if (inView(this, 10)) {
            if (this.targetX > 0) {
              this.x = lerp(this.x, this.targetX, 0.2);
              this.y = lerp(this.y, this.targetY, 0.2);
            }

            let distx = this.x - p.x;
            let disty = this.y - p.y;

            this.dist = Math.sqrt(distx * distx + disty * disty);
            if (this.dist <= this.radius + p.radius + 40) {
              if (p.fuel < p.maxFuel) {
                this.radius -= 0.1;
                p.fuel += 1;
                p.absorbing = true;
                this.reaching = true;
                absorbSound.volume.gain.value = 0.1;
              } else if (p.fuel == p.maxFuel) {
                absorbSound.volume.gain.value = 0;
                p.absorbing = false;
              }
            } else {
              this.reaching = false;
            }
          }

          if (this.radius <= 0) {
            playSound(sounds.sectorComplete);
            splodes.push(new Splode(this.x, this.y, 120, 9));
            this.alive = false;
          }
        };

        function Harvester(angle, planet) {
          this.x = 0;
          this.y = 0;
          this.radius = 10;
          this.hit = false;
          this.hitCount = 0;
          this.alive = true;
          this.health = 100;
          this.reaching = false;
          this.angle = angle;
          this.planet = planet;
          this.attacked = false;

          return this;
        }

        Harvester.prototype.draw = function () {
          if (inView(this, 10)) {
            r.fillCircle(this.x - view.x, this.y - view.y, this.radius, 4);
            if (this.reaching) {
              let i = 10;
              while (i--) {
                r.pat = r.dither[i];
                r.line(
                  this.x - view.x + (Math.random() - 0.5) * this.radius * 2,
                  this.y - view.y + (Math.random() - 0.5) * this.radius * 2,
                  p.x - view.x,
                  p.y - view.y,
                  3 + Math.random() * 5,
                );
              }
            }
          }
        };
        Harvester.prototype.update = function () {
          this.x =
            this.planet.x +
            Math.cos(this.angle) * (this.planet.radius + Math.sin(t / 5) * 5);
          this.y =
            this.planet.y +
            Math.sin(this.angle) * (this.planet.radius + Math.sin(t / 5) * 5);
          this.angle += 0.01;
          if (inView(this, -20)) {
            p.enemiesInView.push(this);
          }
          if (inView(this, 10)) {
            let distx = this.x - p.x;
            let disty = this.y - p.y;

            let dist = Math.sqrt(distx * distx + disty * disty);

            if (dist <= this.radius + p.radius + 20) {
              p.fuel -= 0.6;
              p.draining = true;
              this.reaching = true;
              harverterSuckSound.volume.gain.value = 0.1;
              if (dist <= this.radius + p.radius) {
                if (Math.abs(p.xVel + p.yVel) / 2 < 2) {
                  splodes.push(new Splode(this.x, this.y, 20, 22));
                  p.xVel = Math.cos(p.angle) * 4;
                  p.yVel = Math.sin(p.angle) * 4;
                  playSound(sounds.bump, 1, 0, 0.4, false);
                }
              }
            } else {
              this.reaching = false;
              p.draining = false;
            }
            if (this.health < 100 && !this.attacked) {
              playSound(sounds.harvestermoan, 2, 0, 0.2, false);
              this.attacked = true;
            }
            if (this.health <= 0) {
              this.alive = false;
              p.draining = false;
              this.planet.harvesters--;
              harvesters.splice(harvesters.indexOf(this), 1);
              splodes.push(new Splode(this.x, this.y, 50, 6));
              splodes.push(
                new Splode(
                  this.x + Math.random() * 5,
                  this.y + Math.random() * 5,
                  60,
                  7,
                ),
              );
              splodes.push(
                new Splode(
                  this.x + Math.random() * 5,
                  this.y + Math.random() * 5,
                  70,
                  5,
                ),
              );
              playSound(sounds.boom1, 1, 0, 0.1, false);
              for (let i = 0; i < 2; i++) {
                let f = new Fuel(this.x, this.y, 2);
                f.targetX = this.x + Math.random() * 90;
                f.targetY = this.y + Math.random() * 90;
                Fuelrocks.push(f);
              }
            }
          }
          // if(this.radius <= 0){
          //     this.alive = false;
          // }
        };

        const HOME = 0;
        const ORBITING = 3;
        const ATTACKING = 2;

        function Baby(x, y) {
          this.state = 0;
          this.previousState = 0;
          this.angle = 0;
          this.targetAngle = 0;

          this.x = x;
          this.y = y;
          this.targetX = 0;
          this.targetY = 0;

          this.alive = true;

          this.updateOrbits();

          return this;
        }

        Baby.prototype.draw = function () {
          if (inView(this, 10)) {
            switch (this.state) {
              case HOME:
              case ORBITING:
                r.fillCircle(this.x - view.x, this.y - view.y, 2, 0);
                r.circle(
                  this.x - view.x,
                  this.y - view.y,
                  2,
                  choice([19, 20, 22]),
                );
                splodes.push(
                  new Splode(this.x, this.y, 5, choice([19, 20, 22])),
                );
                break;
              case ATTACKING:
                r.fillCircle(this.x - view.x, this.y - view.y, 2, 0);
                r.circle(
                  this.x - view.x,
                  this.y - view.y,
                  2,
                  choice([5, 6, 7]),
                );
                splodes.push(new Splode(this.x, this.y, 5, choice([5, 6, 7])));
                splodes.push(
                  new Splode(
                    this.enemyTarget.x +
                      (Math.random() * 2 - 1) * this.enemyTarget.radius,
                    this.enemyTarget.y +
                      (Math.random() * 2 - 1) * this.enemyTarget.radius,
                    5,
                    choice([5, 6, 7]),
                  ),
                );
                break;
            }
          }
        };
        Baby.prototype.update = function () {
          if (this.state != this.previousState) {
            //playSound(sounds.babyaction2, 1, 0, 0.1, false);
            this.previousState = this.state;
          }

          if (!inView(this, 20)) {
            this.state = HOME;
          }

          this.targetAngle += 0.015;
          if (p.enemiesInView.length > 0 && this.state != ATTACKING) {
            this.enemyTarget = choice(p.enemiesInView);
            this.state = ATTACKING;
          } else if (p.enemiesInView.length == 0) {
            this.state = HOME;
            if (p.withinPlanetGravity) {
              this.state = ORBITING;
            }
          }

          switch (this.state) {
            case HOME:
              this.targetX =
                p.x +
                Math.cos(this.angle) * (p.radius + babies.length - p.xVel * 2) +
                Math.cos(this.angle * 7) * 20;
              this.targetY =
                p.y +
                Math.sin(this.angle) * (p.radius + babies.length - p.yVel * 2) +
                Math.sin(this.angle * 7.1) * 20;
              if (this.enemyTarget) {
                this.enemyTarget.attacked = false;
              }

              break;

            case ORBITING:
              this.targetX =
                p.planet.x +
                Math.cos(this.angle) *
                  (p.planet.radius + 7 + babies.length - p.xVel * 2);
              this.targetY =
                p.planet.y +
                Math.sin(this.angle) *
                  (p.planet.radius + 7 + babies.length - p.yVel * 2);
              break;

            case ATTACKING:
              this.targetX =
                this.enemyTarget.x +
                Math.cos(this.angle) * (this.enemyTarget.radius + 5);
              this.targetY =
                this.enemyTarget.y +
                Math.sin(this.angle) * (this.enemyTarget.radius + 5);
              this.enemyTarget.health -= 0.2;
              //this.enemyTarget.underAttack = true;
              if (!this.enemyTarget.alive) {
                //playSound(sounds.babyaction1, 1, 0, 0.1, false);
                this.enemyTarget = choice(p.enemiesInView);
              }
              break;
          }

          this.x = lerp(this.x, this.targetX, 0.15);
          this.y = lerp(this.y, this.targetY, 0.15);
          this.angle = lerp(this.angle, this.targetAngle, 0.15);

          if (inView(this, 10));
        };

        Baby.prototype.updateOrbits = function () {
          babies.forEach(function (e, i, a) {
            e.targetAngle = ((Math.PI * 2) / (a.length + 1)) * (i + 1);
          });
        };

        function Planet() {
          this.x = 0;
          this.y = 0;
          this.radius = 25;
          this.field = this.radius + 30;
          this.color = 22;
          this.haloColor = 19;
          this.palette = [0, 1, 2, 3, 4, 5, 6];
          this.gravity = 0.15;
          this.sectors = 1;
          this.harvesters = 0;

          this.sectorsRemaining = this.sectors;
          this.completeFlag = false;
          this.populated = false;
          this.drawColor = 37;
          this.disease = [];

          return this;
        }
        Planet.prototype.draw = function () {
          r.renderSource = r.PAGE_2;

          if (inView(this, 2500) && !inView(this, 50)) {
            //radar HUD
            let ax = this.x - p.x,
              ay = this.y - p.y,
              arrowAngle = Math.atan2(ay, ax),
              drawX = p.x - view.x + Math.cos(arrowAngle) * (h / 2 - 20);
            drawY = p.y - view.y + Math.sin(arrowAngle) * (h / 2 - 20);
            let dist = Math.sqrt(ax * ax + ay * ay);

            if (dist / 100 < 12) {
              r.pat = r.dither[8];
              r.circle(
                drawX,
                drawY,
                12 - Math.min(12, Math.floor(dist / 100)),
                this.completeFlag ? 19 : 7,
              );
              r.pat = r.dither[0];
            }
          }

          if (inView(this, 200)) {
            //only draw the pretty stuff if the planet is fully pollinated
            if (this.sectorsRemaining == 0) {
              //oooh its pretty atmosphere halo time
              //outer haze
              r.pat = r.dither[15];
              r.fillCircle(
                this.x - view.x,
                this.y - view.y,
                this.radius + 30,
                this.haloColor,
              );
              //a bit thicker now
              r.pat = r.dither[13];
              r.fillCircle(
                this.x - view.x,
                this.y - view.y,
                this.radius + 20,
                this.haloColor,
              );
              r.pat = r.dither[11];
              //moar thick
              r.fillCircle(
                this.x - view.x,
                this.y - view.y,
                this.radius + 8,
                this.haloColor,
              );
              r.pat = r.dither[8];
              //that neat bright blue bit near the horizon
              r.fillCircle(
                this.x - view.x,
                this.y - view.y,
                this.radius + 3,
                this.haloColor,
              );
              r.fillCircle(
                this.x - view.x,
                this.y - view.y,
                this.radius + 2,
                this.haloColor + 1,
              );

              if (this.reaching) {
                r.pat = r.dither[12];
                let i = 10;
                while (i--) {
                  r.line(
                    this.x - view.x + (Math.random() - 0.5) * this.radius * 2,
                    this.y - view.y + (Math.random() - 0.5) * this.radius * 2,
                    p.x - view.x + (Math.random() - 0.5) * p.radius,
                    p.y - view.y + (Math.random() - 0.5) * p.radius,
                    18 + Math.random() * 4,
                  );
                }
                r.pat = r.dither[0];
              }
            }

            r.pat = r.dither[0];
            //the planet itself
            r.tfillCircle(
              this.x - view.x,
              this.y - view.y,
              this.radius,
              this.drawColor,
            );

            //icky gray stuff
            r.pat = r.dither[8];
            this.disease.forEach(function (d) {
              r.pat = r.dither[d.dither];
              // let px = (d.x)
              // let py = (d.y)
              // let rotatedX = px * Math.cos(3) - py * Math.sin(3);
              // let rotatedY = px * Math.sin(3) + py * Math.cos(3);
              // let newX =  px + this.x;
              // let newY = py + this.y;
              // r.fillCircle(newX, newY, d.radius, 42);
              r.fillCircle(d.x - view.x, d.y - view.y, d.radius, 42);
            });

            //a bright cyan line to finish it off --dark red if its not pollinated
            r.circle(
              this.x - view.x,
              this.y - view.y,
              this.radius,
              this.sectorsRemaining == 0 ? 19 : 4,
            );

            //the planet gravity field
            r.circle(this.x - view.x, this.y - view.y, this.field, 1);
          }
        };
        Planet.prototype.update = function () {
          if (inView(this, 200)) {
            this.reaching = false;
            if (!this.populated) {
              planetsDiscovered++;
              this.field = this.radius + 45;
              this.haloColor = choice([18, 15, 29]);
              this.sectors = Math.round(this.radius / 10);
              this.sectorsRemaining = this.sectors;

              for (let i = 0; i < this.sectors; i++) {
                let x =
                  this.x +
                  this.radius * Math.cos((i * (2 * Math.PI)) / this.sectors);
                let y =
                  this.y +
                  this.radius * Math.sin((i * (2 * Math.PI)) / this.sectors);
                //r.circle(x - view.x, y - view.y, 2, 22);
                planetSectors.push(new Sector(x, y, this));
              }
              for (let i = 0; i < this.harvesters; i++) {
                let angle = ((2 * Math.PI) / this.harvesters) * i;
                harvesters.push(new Harvester(angle, this));
              }
              for (let i = 0; i < 300; i++) {
                this.disease.push({
                  x:
                    this.x +
                    Math.cos(Math.random() * 3.14159 * 2) *
                      Math.random() *
                      this.radius,
                  y:
                    this.y +
                    Math.sin(Math.random() * 3.14159 * 2) *
                      Math.random() *
                      this.radius,
                  radius: Math.random() * 12,
                  dither: Math.floor(8 + Math.random() * 4),
                });
              }
              this.populated = true;
            }
            if (this.sectorsRemaining == 0) {
              this.drawColor = this.color;
              if (!this.completeFlag) {
                this.completeFlag = true;
                planetsComplete++;
                playSound(sounds.tada);
                this.disease = [];
                let i = 80;
                while (i--) {
                  let a = Math.random() * 3.14159 * 2;
                  let r = Math.random() * this.radius;
                  splodes.push(
                    new Splode(
                      this.x + r * Math.cos(a),
                      this.y + r * Math.sin(a),
                      20 + Math.random() * 50,
                      choice([20, 21, 22]),
                    ),
                  );
                }
                babies.push(new Baby(this.x, this.y));
              }
            }

            let distx = this.x - p.x;
            let disty = this.y - p.y;

            let dist = Math.sqrt(distx * distx + disty * disty);
            if (dist <= this.field + p.radius + 100) {
              this.reaching = true;
            }
            if (this.completeFlag && this.reaching) {
              p.fuel += 0.12;
            }
            if (dist <= this.field + p.radius) {
              if (!p.withinPlanetGravity) {
                p.onPlanet(this);
              }
            }
          }
        };

        function Drone(angle, planet) {
          this.x = 0;
          this.y = 0;
          this.targetX = 0;
          this.targetY = 0;
          this.radius = 8;
          this.hit = false;
          this.hitCount = 0;
          this.alive = true;
          this.health = 600;
          this.reaching = false;
          this.angle = angle;
          this.planet = planet;
          this.harvesters = 3;
          this.apex = { x: 0, y: 0 };
          this.browL = { x: 0, y: 0 };
          this.browR = { x: 0, y: 0 };
          this.armSpeedFactor = 60;
          this.armSpeedTarget = 0;
          this.underAttack = false;

          return this;
        }

        Drone.prototype.draw = function () {
          if (inView(this, 10)) {
            r.pat = r.dither[0];

            for (let a = 0; a < 2 * Math.PI; a += 0.7) {
              for (let rad = this.radius; rad < this.radius + 30; rad += 4) {
                let v =
                  a +
                  0.4 * Math.sin(a * 8 - rad / 20 + t / this.armSpeedTarget);
                r.fillCircle(
                  this.x - view.x + rad * Math.cos(v),
                  this.y - view.y + rad * Math.sin(v),
                  (this.radius / 3 - rad / 11) | 0,
                  3,
                );
                r.circle(
                  this.x - view.x + rad * Math.cos(v),
                  this.y - view.y + rad * Math.sin(v),
                  (this.radius / 3 - rad / 11) | 0,
                  4,
                );
              }
            }

            r.fillCircle(this.x - view.x, this.y - view.y, this.radius, 3);
            r.fillCircle(this.x - view.x, this.y - view.y, 15, 22);
            r.fillCircle(
              this.x - view.x + Math.cos(this.angle + Math.PI) * 7,
              this.y - view.y + Math.sin(this.angle + Math.PI) * 7,
              3,
              1,
            );
            //r.fillTriangle(this.browL, this.browR, this.apex, 3);
            r.circle(this.x - view.x, this.y - view.y, this.radius, 4);

            if (this.reaching) {
              this.armSpeedTarget = 10;
              let i = 10;
              while (i--) {
                r.pat = r.dither[i];
                r.line(
                  this.x - view.x + (Math.random() - 0.5) * this.radius * 2,
                  this.y - view.y + (Math.random() - 0.5) * this.radius * 2,
                  p.x - view.x,
                  p.y - view.y,
                  3 + Math.random() * 5,
                );
              }
            } else {
              this.armSpeedTarget = 60;
            }
          }
        };
        Drone.prototype.update = function () {
          if (inView(this, -20)) {
            p.enemiesInView.push(this);
          }
          if (inView(this, 60)) {
            this.targetX = p.x;
            this.targetY = p.y;
            this.x = lerp(this.x, this.targetX, 0.005);
            this.y = lerp(this.y, this.targetY, 0.005);
            this.armSpeedFactor = lerp(
              this.armSpeedFactor,
              this.armSpeedTarget,
              0.2,
            );

            this.apex.x = this.x - view.x;
            this.apex.y = this.y - view.y - 3;

            this.browL.x = this.x - view.x - 24;
            this.browL.y = this.y - view.y - 18;

            this.browR.x = this.x - view.x + 24;
            this.browR.y = this.y - view.y - 18;

            let distx = this.x - p.x;
            let disty = this.y - p.y;

            this.angle = Math.atan2(disty, distx);

            let dist = Math.sqrt(distx * distx + disty * disty);

            if (dist <= this.radius + p.radius + 100) {
              p.fuel -= 0.6;
              this.reaching = true;
              p.draining = true;
              harverterSuckSound.volume.gain.value = 0.1;
              if (dist <= this.radius + p.radius) {
                p.fuel -= 150;
                if (Math.abs(p.xVel + p.yVel) / 2 < 2) {
                  if (p.fuel > 100) {
                    p.score += 1;
                    this.hit = true;
                    this.hitCount += 1;
                    splodes.push(new Splode(this.x, this.y, 40, 5));
                    playSound(sounds.boom1, 3, 0, 0.05, false);

                    p.xVel = Math.cos(p.angle) * 3;
                    p.yVel = Math.sin(p.angle) * 3;
                  } else {
                    splodes.push(new Splode(this.x, this.y, 20, 22));
                    p.xVel = Math.cos(p.angle) * 5;
                    p.yVel = Math.sin(p.angle) * 5;
                    playSound(sounds.bump, 1, 0, 0.4, false);
                  }
                }
              }
            } else {
              this.reaching = false;
              p.draining = false;
            }
            if (this.health <= 0) {
              this.alive = false;
              p.draining = false;
              drones.splice(drones.indexOf(this), 1);
              splodes.push(new Splode(this.x, this.y, 50, 6));
              splodes.push(
                new Splode(
                  this.x + Math.random() * 5,
                  this.y + Math.random() * 5,
                  60,
                  7,
                ),
              );
              splodes.push(
                new Splode(
                  this.x + Math.random() * 5,
                  this.y + Math.random() * 5,
                  70,
                  5,
                ),
              );
              for (let i = 0; i < 5; i++) {
                let f = new Fuel(this.x, this.y, 2);
                f.targetX = this.x + (Math.random() - 0.5) * 150;
                f.targetY = this.y + (Math.random() - 0.5) * 150;
                Fuelrocks.push(f);
              }
              playSound(sounds.boom1, 1, 0, 0.1, false);
            }
          }
          // if(this.radius <= 0){
          //     this.alive = false;
          // }
        };

        /*
  TODO:  Prioritized


  mini-map
  show completed planets
    as percentage or ratio
  show # of babies

  Credits!
  Herebefrogs for detailed feedback and game boilerplate
  Yarume for Roadroller
  Darthlupi for game design
  Soundbox creator for music/sound synth

  giant flying drones
    giant flying drones are damaged by complete planets

  balance
    tighten up controls
    find goldilocks zone for planet spawn density

   

  Visuals/polish

    babies
      alter orbit pattern to something more interesting than circle
      visual/audio feedback for adding a baby to the collection

    harvesters
    shorten hurt sound
    visual feedback for hurt
      change drawing to pointy triangle with tiny eye
      legs?

    player
      Improve leg motion on planet

    nebulae/star clusters
      -different colors put in behind planets after init
      -denser than existing special star groups
        drawn with dithered circles instead of points
    
    shooting stars

    improved/more varied planet drawiing
     -more stencil sheets with striations at different angles
     -simple lighting?

  sound design:
    music is expanded upon, more melody

  intelligent entity placement
    DUN -planets are placed in world with no overlap



  */
        window.baby = Baby;
        //stats = new Stats();
        //stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
        document.body.style =
          "margin:0; background-color:black; overflow:hidden";
        if (innerWidth < 800) {
          w = innerWidth;
          h = innerHeight;
        } else if (innerWidth < 1300) {
          w = Math.floor(innerWidth / 2);
          h = Math.floor(innerHeight / 2);
        } else {
          w = Math.floor(innerWidth / 3.5);
          h = Math.floor(innerHeight / 3.5);
        }

        wwFactor = 40;
        hhFactor = 40;
        Ww = w * wwFactor;
        Wh = h * hhFactor;
        view = {
          x: 0,
          y: 0,
        };
        mw = w / 2;
        mh = h / 2;
        gamestate = 0;
        paused = false;
        started = false;

        p = Player$1;
        p.x = Ww / 2;
        p.y = Wh / 2;
        const atlasURL =
          "data:image/webp;base64,UklGRgYBAABXRUJQVlA4TPkAAAAvPwAAAAmAIPx/e4jof2oBEIT/bw8R/U/BbQAAZBPbrG0bm77naNt2L3FjAQCpfJvZtdk21m7QhbpU769xtW3XZicCAJBRmm1G6wHry3sBv3oJ2TaTzQgMgykOw60sEIPJ/NfmfEb0m+KfSWGWH/i/u8auMllLp0n52cfoLvVtXVYKFAcUZfWj5j87X4mHi8bzX1l8HrX3pPYcTlvOVVr9qo3Lavb/rXmB1LJcpoDHLXpMG3GbpNff9Hvj+WI8GbdW+8mBP7FawBlU3S655I2Sr7TX+Qybu3urf71W96O6lRfDTjcaDs1JZ6CujZezdr8z65838/1hdwAA";
        atlasImage = new Image();
        atlasImage.src = atlasURL;

        atlasImage.onload = function () {
          let c = document.createElement("canvas");
          c.width = 64;
          c.height = 64;
          let ctx = c.getContext("2d");
          ctx.drawImage(this, 0, 0);
          atlas = new Uint32Array(ctx.getImageData(0, 0, 64, 64).data.buffer);
          window.r = new RetroBuffer(w, h, atlas, 10);
          gameInit();
        };

        function gameInit() {
          window.playSound = playSound;
          gamebox = document.getElementById("game");
          gamebox.appendChild(r.c);
          gameloop();
        }

        //document.body.appendChild( stats.dom );

        window.t = 1;
        splodes = [];
        planets = [];
        sndData = [];
        Fuelrocks = [];
        planetSectors = [];
        harvesters = [];
        stars = [];
        collected = [];
        babies = [];
        drones = [];

        artifacts = [];

        sounds = {};
        soundsReady = 0;
        totalSounds = 8;
        audioTxt = "";
        debugText = "";
        darkness = 0;
        planetsComplete = 0;
        planetsDiscovered = 0;
        absorbSound = {};
        harverterSuckSound = {};
        sectorFillSound = {};
        gameMusicSound = 0;
        minimapToggle = false;
        procGenStart = 5;
        helpToggle = false;

        function initGameData() {
          //hand placed items as tutorial area---------------------------------

          let pl = new Planet();
          pl.x = p.x - 100;
          pl.y = p.y - 100;
          pl.radius = 25;
          pl.harvesters = 0;
          planets.push(pl);

          pl = new Planet();
          pl.x = p.x + 200;
          pl.y = p.y - 100;
          pl.radius = 25;
          pl.color = 4;
          pl.harvesters = 0;
          planets.push(pl);

          pl = new Planet();
          pl.x = p.x;
          pl.y = p.y + 100;
          pl.radius = 25;
          pl.color = 22;
          pl.harvesters = 0;
          planets.push(pl);

          pl = new Fuel(p.x + 150, p.y, 20);
          Fuelrocks.push(pl);

          //---------------------------------------------------------------------

          for (let i = 0; i < 1000; i++) {
            let p = new Planet();
            p.x = Math.floor(Math.random() * (Ww - w * 2) + h); //spawn planets not too close to edge of world
            p.y = Math.floor(Math.random() * (Wh - h * 2) + h);

            let radius = Math.max(Math.floor(Math.random() * h * 0.45), 10);
            p.radius = radius;
            p.field = radius + 45;
            p.harvesters =
              Math.floor(p.radius / 20) + Math.floor(Math.random() * 5);
            let c = Math.floor(Math.random() * 55);
            p.color = c;
            collides = true;
            if (doesPlanetHaveCollision(p, 100)) {
              continue;
            } else {
              planets.push(p);
            }
          }
          //a batch of super small planets
          for (let i = 0; i < 100; i++) {
            let p = new Planet();
            p.x = Math.floor(Math.random() * (Ww - w * 2) + h); //spawn planets not too close to edge of world
            p.y = Math.floor(Math.random() * (Wh - h * 2) + h);

            p.radius = 15;
            p.field = p.radius + 45;
            p.harvesters = Math.round(Math.random());
            let c = Math.floor(Math.random() * 55);
            p.color = c;
            collides = true;
            if (doesPlanetHaveCollision(p, 100)) {
              continue;
            } else {
              planets.push(p);
            }
          }
          for (let i = 0; i < 200; i++) {
            let replacePlanet =
              planets[
                procGenStart +
                  Math.floor(Math.random() * (planets.length - procGenStart))
              ];
            let d = new Fuel(0, 0, 1);
            d.x = replacePlanet.x;
            d.y = replacePlanet.y;
            d.radius = 10 + Math.random() * 10;
            planets.splice(planets.indexOf(replacePlanet), 1);

            Fuelrocks.push(d);
          }
          for (let i = 0; i < 125; i++) {
            let replacePlanet =
              planets[
                procGenStart +
                  Math.floor(Math.random() * (planets.length - procGenStart))
              ];
            let d = new Drone();
            d.x = replacePlanet.x;
            d.y = replacePlanet.y;
            d.radius = Math.max(Math.random() * 30, 10);
            planets.splice(planets.indexOf(replacePlanet), 1);
            drones.push(d);
          }

          for (let i = 0; i < 5000; i++) {
            let star = [];
            let x = Math.floor(Math.random() * Ww);
            let y = Math.floor(Math.random() * Wh);
            for (let j = 0; j < 10; j++) {
              let sx = x + (Math.random() - 0.5) * 100;
              let sy = y + (Math.random() - 0.5) * 100;
              star.push({
                x: sx,
                y: sy,
                c: Math.floor(Math.random() * 5) + 18,
              });
            }
            stars.push({ x: x, y: y, star: star });
          }

          for (let i = 0; i < 30000; i++) {
            let star = [];
            let x = Math.floor(Math.random() * Ww);
            let y = Math.floor(Math.random() * Wh);
            for (let j = 0; j < 10; j++) {
              let sx = x + (Math.random() - 0.5) * 100;
              let sy = y + (Math.random() - 0.5) * 100;
              star.push({ x: sx, y: sy, c: choice([30, 31, 43, 1]) });
            }
            stars.push({ x: x, y: y, star: star });
          }

          //Green stardust behind fuel rocks
          Fuelrocks.forEach(function (f) {
            let star = [];
            for (let j = 0; j < 300; j++) {
              let sx =
                f.x +
                Math.cos(Math.random() * Math.PI * 2) * Math.random() * 100;
              let sy =
                f.y +
                Math.sin(Math.random() * Math.PI * 2) * Math.random() * 100;
              star.push({ x: sx, y: sy, c: choice([14, 15, 16]) });
            }
            stars.push({ x: f.x, y: f.y, star: star });
          });

          //red stardust behind drones
          drones.forEach(function (f) {
            let star = [];
            for (let j = 0; j < 300; j++) {
              let sx =
                f.x +
                Math.cos(Math.random() * Math.PI * 2) * Math.random() * 150;
              let sy =
                f.y +
                Math.sin(Math.random() * Math.PI * 2) * Math.random() * 150;
              star.push({ x: sx, y: sy, c: choice([3, 4, 5]) });
            }
            stars.push({ x: f.x, y: f.y, star: star });
          });

          // for(let i = 0; i < 100; i++){
          //   artifacts.push(new Artifact(
          //     Math.floor(Math.random()*(Ww)),
          //     Math.floor(Math.random()*(Wh)),
          //     Math.floor(Math.random()*(20)),
          //     Math.floor(Math.random()*(63))
          //   ));
          // }
          //populate buffer with something to fill planets with
          r.renderTarget = r.PAGE_2;
          r.pal = r.palDefault;
          r.fillRect(0, 0, w, h, 1);

          for (let i = 0; i < 5000; i++) {
            r.pat = r.dither[Math.floor(Math.random() * 15)];
            r.fillCircle(
              Math.random() * w,
              Math.random() * h,
              Math.random() * 4,
              Math.floor(Math.random() * 5),
            );
          }
          for (let i = 0; i < 500; i++) {
            r.pat = r.dither[Math.floor(Math.random() * 15)];
            r.fillCircle(
              Math.random() * w,
              Math.random() * h,
              Math.random() * 20,
              Math.floor(Math.random() * 7),
            );
          }

          let i = 50000;

          r.pat = r.dither[0];
          while (i--) {
            r.renderTarget = r.PAGE_2;
            let x = Math.random() * w;
            let y = Math.random() * h;
            let c = r.pget(x, y, r.PAGE_2);
            r.line(x, y, x + Math.random() * 10, y + 4, c);
          }
          r.pat = r.dither[0];

          r.renderTarget = r.SCREEN;
        }

        function initAudio() {
          audioCtx = new AudioContext();
          audioMaster = audioCtx.createGain();
          compressor = audioCtx.createDynamicsCompressor();
          compressor.threshold.setValueAtTime(-60, audioCtx.currentTime);
          compressor.knee.setValueAtTime(40, audioCtx.currentTime);
          compressor.ratio.setValueAtTime(12, audioCtx.currentTime);
          compressor.attack.setValueAtTime(0, audioCtx.currentTime);
          compressor.release.setValueAtTime(0.25, audioCtx.currentTime);

          audioMaster.connect(compressor);
          compressor.connect(audioCtx.destination);

          sndData = [
            { name: "song", data: song },
            { name: "cellComplete", data: cellComplete },
            { name: "tada", data: tada },
            { name: "boom1", data: boom1 },
            { name: "jet", data: jet },
            { name: "absorbray", data: absorbray },
            { name: "sectorget", data: sectorget },
            { name: "bump", data: bump },
            { name: "dronemoan", data: dronemoan },
            { name: "harvestermoan", data: harvestermoan },
            { name: "babyaction", data: babyaction },
            { name: "babyaction2", data: babyaction2 },
          ];
          totalSounds = sndData.length;
          soundsReady = 0;
          sndData.forEach(function (o) {
            var sndGenerator = new MusicPlayer();
            sndGenerator.init(o.data);
            var done = false;
            setInterval(function () {
              if (done) {
                return;
              }
              done = sndGenerator.generate() == 1;
              soundsReady += done;
              if (done) {
                let wave = sndGenerator.createWave().buffer;
                audioCtx.decodeAudioData(wave, function (buffer) {
                  sounds[o.name] = buffer;
                  //soundsReady++;
                });
              }
            }, 0);
          });
        }

        function drawMiniMap() {
          if (mapTriggered) {
            scale = wwFactor;
            mapTriggered = false;
          }

          scaleTarget = 3;
          scale = lerp(scale, scaleTarget, 0.5);
          r.pal = r.palDefault;
          r.fillRect(0, 0, w, h, 0);
          let mapFactorW = wwFactor / scale;
          let mapFactorH = hhFactor / scale;
          view.x = p.x - mw * mapFactorW;
          view.y = p.y - mh * mapFactorH;
          let mapViewX = view.x / mapFactorW;
          let mapViewY = view.y / mapFactorH;

          r.pat = r.dither[8];
          stars.forEach(function (e, i) {
            if (i % 2 == 0) {
              if (inView(e, mapFactorW * Ww)) {
                if (i % 5 == 0) {
                  e.star.forEach(function (s, i) {
                    r.pset(
                      s.x / mapFactorW - mapViewX,
                      s.y / mapFactorH - mapViewY,
                      1,
                    );
                  });
                }
              }
            }
          });
          r.pat = r.dither[0];

          planets.forEach(function (p) {
            r.fillCircle(
              p.x / mapFactorW - mapViewX,
              p.y / mapFactorH - mapViewY,
              Math.max(p.radius / mapFactorW, 2),
              p.sectorsRemaining == 0 ? p.color : 2,
            );
            if (p.sectorsRemaining == 0) {
              r.circle(
                p.x / mapFactorW - mapViewX,
                p.y / mapFactorH - mapViewY,
                Math.max(p.radius / mapFactorW, 2),
                19,
              );
            }
          });

          Fuelrocks.forEach(function (f) {
            r.pset(
              f.x / mapFactorW - mapViewX,
              f.y / mapFactorH - mapViewY,
              10,
            );
            r.pset(
              f.x / mapFactorW - mapViewX + 1,
              f.y / mapFactorH - mapViewY,
              10,
            );
            r.pset(
              f.x / mapFactorW - mapViewX - 1,
              f.y / mapFactorH - mapViewY,
              10,
            );
            r.pset(
              f.x / mapFactorW - mapViewX,
              f.y / mapFactorH + 1 - mapViewY,
              10,
            );
            r.pset(
              f.x / mapFactorW - mapViewX,
              f.y / mapFactorH - 1 - mapViewY,
              10,
            );
          });
          harvesters.forEach(function (f) {
            r.pset(f.x / mapFactorW - mapViewX, f.y / mapFactorH - mapViewY, 4);
          });
          drones.forEach(function (f) {
            r.fillCircle(
              f.x / mapFactorW - mapViewX,
              f.y / mapFactorH - mapViewY,
              1,
              4,
            );
          });

          if (t % 2 == 0) {
            r.pset(p.x / mapFactorW, p.y / mapFactorH, 9);
            r.pset(
              p.x / mapFactorW + 1 - mapViewX,
              p.y / mapFactorH + 1 - mapViewY,
              22,
            );
            r.pset(
              p.x / mapFactorW - 1 - mapViewX,
              p.y / mapFactorH - 1 - mapViewY,
              22,
            );
            r.pset(
              p.x / mapFactorW - 1 - mapViewX,
              p.y / mapFactorH + 1 - mapViewY,
              22,
            );
            r.pset(
              p.x / mapFactorW + 1 - mapViewX,
              p.y / mapFactorH - 1 - mapViewY,
              22,
            );
            r.pset(
              p.x / mapFactorW + 2 - mapViewX,
              p.y / mapFactorH + 2 - mapViewY,
              22,
            );
            r.pset(
              p.x / mapFactorW - 2 - mapViewX,
              p.y / mapFactorH - 2 - mapViewY,
              22,
            );
            r.pset(
              p.x / mapFactorW - 2 - mapViewX,
              p.y / mapFactorH + 2 - mapViewY,
              22,
            );
            r.pset(
              p.x / mapFactorW + 2 - mapViewX,
              p.y / mapFactorH - 2 - mapViewY,
              22,
            );
          }

          r.text([
            `${planetsDiscovered}/${planets.length} PLANETS DISCOVERED  ${planetsComplete} PLANETS COMPLETE`,
            w / 2,
            15,
            1,
            3,
            "center",
            "top",
            1,
            7,
          ]);
        }

        function drawHUD() {
          fuelBarWidth = (p.fuel / p.maxFuel) * (w / 2);

          r.fillRect(w / 4, 10, w / 2, 3, 2);
          r.fillRect(w / 4, 10, fuelBarWidth, 3, 12);
        }

        function drawHelp() {
          playerHelpText = "W/Z/UP TO THRUST\nAD/QD TO TURN";

          if (t % 300 < 150 && p.fuel < 5) {
            playerHelpText =
              "FIND ENERGY MASS TO ABSORB\nOR TRAVEL NEAR COMPLETE PLANETS\nTO RECHARGE";
          }

          if (p.withinPlanetGravity) {
            if (p.planet.sectorsRemaining > 0) {
              if (p.planet.harvesters > 0) {
                playerHelpText =
                  "THE RED CAN ONLY\nBE KILLED BY PLANET SPRITES";
              } else {
                if (t % 300 < 150) {
                  playerHelpText =
                    "CHARGE UP PLANET NODES\nTO COMPLETE PLANETS";
                } else {
                  playerHelpText =
                    "COMPLETING A PLANET GIVES\nYOU A PLANET SPRITE";
                }
              }
            } else {
              playerHelpText =
                "COMPLETED PLANETS RECHARGE\nYOUR ENERGY WHEN CLOSE";
              if (t % 300 < 150) {
                playerHelpText =
                  "PLANET SPRITES FOLLOW YOU\nFOREVER AND ATTACK THE RED";
              }
            }
          }

          if (p.draining) {
            playerHelpText = "THE RED DRAIN YOUR ENERGIES\nKEEP YOUR DISTANCE";
          }

          r.text([
            playerHelpText,
            p.x - view.x,
            p.y - view.y + 20,
            1,
            3,
            "center",
            "top",
            1,
            7,
          ]);
          r.text(["ENERGY REMAINING", w / 2, 15, 1, 3, "center", "top", 1, 7]);

          r.pat = r.dither[12];
          r.circle(mw, mh, mh - 10, 7);
          r.pat = r.dither[0];
          r.text([
            "HUD INDICATES\nNEARBY PLANETS",
            mw + mh,
            mh + mh / 2,
            1,
            3,
            "right",
            "top",
            1,
            7,
          ]);
        }

        /*
    ______                                            ______     __                 __                         
   /      \                                          /      \   |  \               |  \                        
  |  $$$$$$\  ______   ______ ____    ______        |  $$$$$$\ _| $$_     ______  _| $$_     ______    _______ 
  | $$ __\$$ |      \ |      \    \  /      \       | $$___\$$|   $$ \   |      \|   $$ \   /      \  /       \
  | $$|    \  \$$$$$$\| $$$$$$\$$$$\|  $$$$$$\       \$$    \  \$$$$$$    \$$$$$$\\$$$$$$  |  $$$$$$\|  $$$$$$$
  | $$ \$$$$ /      $$| $$ | $$ | $$| $$    $$       _\$$$$$$\  | $$ __  /      $$ | $$ __ | $$    $$ \$$    \ 
  | $$__| $$|  $$$$$$$| $$ | $$ | $$| $$$$$$$$      |  \__| $$  | $$|  \|  $$$$$$$ | $$|  \| $$$$$$$$ _\$$$$$$\
   \$$    $$ \$$    $$| $$ | $$ | $$ \$$     \       \$$    $$   \$$  $$ \$$    $$  \$$  $$ \$$     \|       $$
    \$$$$$$   \$$$$$$$ \$$  \$$  \$$  \$$$$$$$        \$$$$$$     \$$$$   \$$$$$$$   \$$$$   \$$$$$$$ \$$$$$$$ 
                                                                                                               
                                                                                                                                                                                                                         
  */
        function updateGame() {
          t += 1;
          try {
            absorbSound.volume.gain.value = 0;
            harverterSuckSound.volume.gain.value = 0;
            sectorFillSound.volume.gain.value = 0;
          } catch {}

          view.x = p.x - mw;
          view.y = p.y - mh;
          Fuelrocks.forEach((e) => e.update());
          splodes.forEach((e) => e.update());
          planets.forEach((e) => e.update());
          artifacts.forEach((e) => e.update());
          planetSectors.forEach((e) => e.update());
          harvesters.forEach((e) => e.update());
          babies.forEach((e) => e.update());
          drones.forEach((e) => e.update());
          p.update();
          pruneDead(splodes);
          pruneDead(artifacts);
          pruneDead(Fuelrocks);
          pruneDead(planetSectors);
          pruneDead(harvesters);
          pruneDead(babies);
          pruneDead(drones);
          pruneScreen(p.enemiesInView);
          pruneDead(p.enemiesInView);

          if (Key.justReleased(Key.m)) {
            minimapToggle = !minimapToggle;
            mapTriggered = true;
          }
          if (Key.justReleased(Key.h)) {
            helpToggle = !helpToggle;
          }
          if (Key.justReleased(Key.r)) {
            resetGame();
          }
        }

        function drawGame() {
          r.pal = r.brightness;
          r.clear(64, r.PAGE_1);
          r.renderTarget = r.PAGE_1;

          stars.forEach(function (e) {
            if (inView(e, 100)) {
              e.star.forEach(function (s) {
                r.pset(s.x - view.x, s.y - view.y, s.c);
              });
            }
          });
          Fuelrocks.forEach((e) => e.draw());
          planetSectors.forEach((e) => e.draw());
          planets.forEach((e) => e.draw());
          artifacts.forEach((e) => e.draw());
          harvesters.forEach((e) => e.draw());
          drones.forEach((e) => e.draw());
          splodes.forEach((e) => e.draw());
          babies.forEach((e) => e.draw());

          p.draw();

          drawCollected();
          drawHUD();
          if (helpToggle) {
            drawHelp();
          }

          r.text([
            "M MAP/STATS  H TOGGLE HELP",
            w - 8,
            h - 8,
            1,
            3,
            "right",
            "top",
            1,
            19,
          ]);
          r.renderSource = r.PAGE_1;
          r.renderTarget = r.SCREEN;
          r.sspr(0, 0, w, h, 0, 0, w, h, false, false);
          if (minimapToggle) {
            drawMiniMap();
          }
          r.render();
        }

        function resetGame() {
          window.t = 1;
          splodes = [];
          planets = [];
          sndData = [];
          Fuelrocks = [];
          planetSectors = [];
          harvesters = [];
          stars = [];
          collected = [];
          artifacts = [];
          babies = [];
          drones = [];
          r.pat = r.dither[0];
          initGameData();
          p.reset();
          this.triggered = false;
          this.titleInit = false;
          gameState = 2;
        }

        function preload() {
          r.clear(64, r.PAGE_1);
          r.renderTarget = r.PAGE_1;
          if (soundsReady == totalSounds) {
            view.x += 1;
            stars.forEach(function (e) {
              if (inView(e, 100)) {
                e.star.forEach(function (s) {
                  r.pset(s.x - view.x, s.y - view.y, s.c);
                });
              }
            });
          }

          r.text([audioTxt, w / 2 - 2, 100, 1, 3, "center", "top", 1, 22]);
          if (
            Key.justReleased(Key.UP) ||
            Key.justReleased(Key.w) ||
            Key.justReleased(Key.z)
          ) {
            if (soundsReady == 0 && !started) {
              initGameData();
              initAudio();
              started = true;
            } else {
              if (gameMusicSound) {
                gameMusicSound.sound.stop();
              }
              gameMusicSound = playSound(sounds.song, 1, 0, 0.3, true);
              absorbSound = playSound(sounds.absorbray, 1, 0, 0.1, true);
              absorbSound.volume.gain.value = 0;
              harverterSuckSound = playSound(
                sounds.absorbray,
                0.5,
                0,
                0.1,
                true,
              );
              harverterSuckSound.volume.gain.value = 0;
              sectorFillSound = playSound(sounds.absorbray, 1.5, 0, 0.1, true);
              sectorFillSound.volume.gain.value = 0;
              gamestate = 2;
            }
          }
          audioTxt = "CLICK TO INITIALIZE\nGENERATION SEQUENCE";
          if (soundsReady == totalSounds) {
            audioTxt = "ALL SOUNDS RENDERED.\nPRESS UP/W/Z TO CONTINUE";
          } else if (started) {
            audioTxt = "SOUNDS RENDERING... " + soundsReady;
          } else {
            audioTxt = "CLICK TO INITIALIZE\nGENERATION SEQUENCE";
          }
          r.renderSource = r.PAGE_1;
          r.renderTarget = r.SCREEN;
          r.sspr(0, 0, w, h, 0, 0, w, h, false, false);
          r.render();
        }

        function titlescreen() {
          view.x = 0;
          view.y = 0;
          if (!this.titleInit) {
            p.x = w / 2 - 135;
            p.y = 70;
            p.bodyAngle = -Math.PI / 3;

            for (let i = 0; i < 5; i++) {
              babies.push(new Baby(p.x, p.y));
            }
            this.titleInit = true;
          }
          //source for letter innards
          r.renderTarget = r.PAGE_3;
          r.fillRect(0, 0, w, h, 14);
          r.pat = r.dither[8];
          r.fillRect(0, 60, w, 80, 15);
          r.pat = r.dither[4];
          r.fillRect(0, 65, w, 70, 15);
          r.pat = r.dither[2];
          r.fillRect(0, 75, w, 50, 15);
          r.pat = r.dither[8];
          r.fillRect(0, 80, w, 40, 16);
          r.pat = r.dither[4];
          r.fillRect(0, 85, w, 30, 16);
          if (!this.triggered) {
            let i = 20;
            while (i--) {
              let x = Math.random() * w;
              let y = Math.random() * h;
              splodes.push(new Splode(x, y, 20, 11));
            }
            splodes.forEach((e) => e.draw());
            splodes.forEach((e) => e.update());
          }

          r.clear(64, r.PAGE_1);
          r.renderTarget = r.PAGE_1;

          stars.forEach(function (e) {
            if (inView(e, 1000)) {
              e.star.forEach(function (s) {
                r.pset((s.x - view.x) / 2, (s.y - view.y) / 2, s.c);
              });
            }
          });

          //purple planet horizon, using texture on page_2 made for planets in-game
          r.stencil = true;
          r.stencilSource = r.PAGE_2;
          r.stencilOffset = 27;
          r.fillRect(0, h - h / 10, w, h / 10, 0);
          r.stencil = false;
          r.line(0, h - h / 10, w, h - h / 10, 20);

          //draw player with orbiting babies next to SPACE
          p.draw();
          babies.forEach((e) => e.draw());
          babies.forEach((e) => e.update());

          //[textstring, x, y, hspacing, vspacing, halign, valign, scale, color, offset, delay, frequency]
          //hacky bevel around text by 1px offset in all directions
          r.text([
            " SPACE\nGARDEN",
            w / 2 - 1,
            50,
            8,
            10,
            "center",
            "top",
            9,
            12,
          ]);
          r.text([
            " SPACE\nGARDEN",
            w / 2 - 3,
            50,
            8,
            10,
            "center",
            "top",
            9,
            12,
          ]);
          r.text([
            " SPACE\nGARDEN",
            w / 2 - 2,
            51,
            8,
            10,
            "center",
            "top",
            9,
            15,
          ]);
          r.text([
            " SPACE\nGARDEN",
            w / 2 - 2,
            49,
            8,
            10,
            "center",
            "top",
            9,
            11,
          ]);

          //draw the animated innards of the title letters
          r.stencil = true;
          r.stencilSource = r.PAGE_3;
          r.stencilOffset = 0;
          r.text([
            " SPACE\nGARDEN",
            w / 2 - 2,
            50,
            8,
            10,
            "center",
            "top",
            9,
            19,
          ]);
          r.stencil = false;
          r.text([
            "PRESS UP / W / Z TO PLAY",
            w / 2 - 2,
            170,
            1,
            1,
            "center",
            "top",
            1,
            22,
          ]);

          //we're outside of the gameloop, so gotta clean up
          pruneDead(splodes);

          if (
            Key.justReleased(Key.UP) ||
            Key.justReleased(Key.w) ||
            Key.justReleased(Key.z)
          ) {
            p.reset();
            gamestate = 1;
          }

          r.renderSource = r.PAGE_1;
          r.renderTarget = r.SCREEN;
          r.sspr(0, 0, w, h, 0, 0, w, h, false, false);
          r.render();
        }
        //initialize  event listeners--------------------------
        window.addEventListener(
          "keyup",
          function (event) {
            Key.onKeyup(event);
          },
          false,
        );
        window.addEventListener(
          "keydown",
          function (event) {
            Key.onKeydown(event);
          },
          false,
        );
        window.addEventListener(
          "blur",
          function (event) {
            paused = true;
          },
          false,
        );
        window.addEventListener(
          "focus",
          function (event) {
            paused = false;
          },
          false,
        );

        onclick = (e) => {
          x = e.pageX;
          y = e.pageY;
          paused = false;
          switch (gamestate) {
            case 0: // react to clicks on screen 0s
              if (soundsReady == 0 && !started) {
                initGameData();
                initAudio();
                started = true;
              }
              break;
          }
        };

        function pruneDead(entitiesArray) {
          for (let i = 0; i < entitiesArray.length; i++) {
            let e = entitiesArray[i];
            if (!e.alive) {
              entitiesArray.splice(i, 1);
            }
          }
        }

        function pruneScreen(entitiesArray) {
          for (let i = 0; i < entitiesArray.length; i++) {
            let e = entitiesArray[i];
            if (!inView(e)) {
              entitiesArray.splice(i, 1);
            }
          }
        }

        function drawCollected() {
          collected.forEach(function (d, i, a) {
            r.rect(5 + i * 20, h - 20, 10, 10, 22);
            r.fillRect(5 + i * 20, h - 20, 10, 10, d.color);
          });
        }

        function gameloop() {
          {
            //stats.begin();
            switch (gamestate) {
              case 0: //title screen
                preload();
                break;
              case 1: //game
                updateGame();
                drawGame();
                break;
              case 2: //game over
                titlescreen();
                break;
            }
            Key.update();
            // stats.end();
            requestAnimationFrame(gameloop);
          }
        }
      })();
    </script>
    <script type="module">
      const platformInfo = await ext.runtime.getPlatformInfo();

      if (platformInfo.os !== "mac") {
        document.getElementById("frame").style.right = "105px";
      }
    </script>
  </body>
</html>
